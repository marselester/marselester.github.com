<!DOCTYPE html>
<head>
    <meta charset="utf-8" />
    <!-- Set the viewport width to device width for mobile -->
    <meta name="viewport" content="width=device-width" />

    <title>Continuous profiling in Go</title>

    <link rel="stylesheet" href="https://marselester.com/theme/css/normalize.css" />
    <link rel="stylesheet" href="https://marselester.com/theme/css/foundation.min.css" />
    <link rel="stylesheet" href="https://marselester.com/theme/css/style.css" />
    <link rel="stylesheet" href="https://marselester.com/theme/css/pygments.css" />	
    <script src="https://marselester.com/theme/js/custom.modernizr.js"></script>

    <!-- So Firefox can bookmark->"abo this site" -->
        <link href="feeds/all.atom.xml" rel="alternate" title="marselester's blog" type="application/atom+xml">

</head>

<body>

<!-- Nav Bar -->
<nav>
<div class="top-bar">
<div class="row">
    <div class="large-9 large-centered columns">
	    <h1><a href="https://marselester.com">marselester's blog</a></h1>
    </div>
</div>
</div>

<!-- Show menu items and pages -->
<div class="row">
<div class="large-9 columns">
    <ul class="button-group navigation">

            <li><a href="https://marselester.com/pages/about.html" class="button secondary small">About</a></li>
    </ul>
</div>
</div>
</nav>
<!-- End Nav -->


<!-- Main Page Content and Sidebar -->
<div class="row">

    <!-- Main Blog Content -->
    <div class="large-9 columns">
<article>
    <header>
        <h3 class="article-title"><a href="https://marselester.com/continuous-profiling-in-go.html" rel="bookmark"
        title="Permalink to Continuous profiling in Go">Continuous profiling in Go</a></h3>
<a href="http://twitter.com/share" class="twitter-share-button" data-count="horizontal" data-via="marselester">Tweet</a><script type="text/javascript" src="http://platform.twitter.com/widgets.js"></script>
    </header>

<h6 class="subheader" title="2022-04-22T00:00:00+07:00">Fri 22 April 2022
</h6>


    <p>In this post I explore possibilities of continuous profiling of Go programs
using Parca and also peek under the hood of its BPF agent.
You can find the results of my experiments in
<a href="https://github.com/marselester/diy-parca-agent">github.com/marselester/diy-parca-agent</a>.</p>
<h2>Ad hoc profiling</h2>
<p>I was looking for a way to profile Go programs running in Kubernetes
to see where a program spends its CPU time (which functions consume most CPU)
or where memory allocations happen.
Allocations in a frequently called function could cause GC pressure
which in turn could cause latency spikes in HTTP requests.</p>
<p>Latency of the Bookstore service is taken seriously,
so its API server already had <code>import _ "net/http/pprof"</code> to enable profiling with <code>go tool pprof</code> program.
In order to get access to the HTTP server running in the pod
a port forwarder could be used.</p>
<div class="highlight"><pre><span></span><code><span class="go">ï¹© kubectl get pods -A | grep bookstore</span>
<span class="go">default                  bookstore-574897d6-e18e</span>
<span class="go">ï¹© kubectl port-forward -n default bookstore-574897d6-e18e 6060 &amp;</span>
<span class="go">Forwarding from 127.0.0.1:6060 -&gt; 6060</span>
<span class="go">Forwarding from [::1]:6060 -&gt; 6060</span>
<span class="go">ï¹© fg 1</span>
</code></pre></div>

<p>The following URLs under <code>/debug/pprof/</code> provide profiling data.</p>
<div class="highlight"><pre><span></span><code><span class="go">ï¼ƒ 30-second CPU profile.</span>
<span class="go">ï¹© curl http://0.0.0.0:6060/debug/pprof/profile --output ./cpu.pprof</span>
<span class="go">ï¼ƒ Heap allocations profile since the process started</span>
<span class="go">ï¼ƒ including garbage-collected bytes (useful when optimising code).</span>
<span class="go">ï¹© curl http://0.0.0.0:6060/debug/pprof/allocs --output ./heap-all.pprof</span>
<span class="go">ï¼ƒ Heap allocations of live objects (useful when looking for memory leaks).</span>
<span class="go">ï¹© curl http://0.0.0.0:6060/debug/pprof/heap --output ./heap-live.pprof</span>
</code></pre></div>

<p>In order to inspect the heap profile <code>heap-all.pprof</code>
I would need to compile the API <code>server</code> program and fix the search path for source files:</p>
<ul>
<li><code>source_path</code> is an absolute path to your source code (the Bookstore's git repository),
  e.g., on Mac it could be <code>/Users/bob/code/bookstore/</code>.</li>
<li><code>trim_path</code> is a path the profile expects the code to be at, e.g.,
  <code>/opt/bookstore/</code> because the binary was compiled in Docker by CI/CD</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="go">ï¹© GOOS=linux go build ./cmd/server/</span>
<span class="go">ï¹© go tool pprof -source_path=&quot;$(pwd)&quot; -trim_path=/opt/bookstore/ ./server ./heap-all.pprof</span>
<span class="go">ï¹ª web</span>
<span class="go">ï¹ª top10 -cum</span>
</code></pre></div>

<p>The <code>web</code> command opens an allocation graph of function calls.
The <code>top10 -cum</code> command shows top ten functions by allocations in that function
or a function it called (cumulative) down the stack:</p>
<ul>
<li><code>flat</code> is a memory allocated by that function and is held by it</li>
<li><code>cum</code> is a memory allocated by that function or a function it called down the stack.
  When <code>flat</code> and <code>cum</code> numbers match,
  this might indicate the allocated memory is retained.</li>
</ul>
<h2>Continuous profiling</h2>
<p>I could be lucky and discover some obvious problem,
though most likely by the time the profiles are collected it is already too late
because a Kubernetes pod in question is already gone.</p>
<p>A continuous profiler could have collected the data
when a problem was occuring on production,
so I was curious to see what open source tooling is available.
Here is what I found so far:</p>
<ul>
<li><a href="https://www.parca.dev/">Parca</a></li>
<li><a href="https://pyroscope.io/">Pyroscope</a></li>
<li><a href="https://github.com/profefe/profefe">profefe</a></li>
</ul>
<p>All of them are capable, moreover Parca and Pyroscope have BPF agents.
I experimented with Parca more because I stumbled on it earlier.
So here is how Parca Server configuration looked like
when I set it up to collect profiles every minute from the Bookstore service.</p>
<div class="highlight"><pre><span></span><code><span class="nt">debug_info</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="nt">bucket</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;FILESYSTEM&quot;</span><span class="w"></span>
<span class="w">    </span><span class="nt">config</span><span class="p">:</span><span class="w"></span>
<span class="w">      </span><span class="nt">directory</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;./tmp&quot;</span><span class="w"></span>
<span class="w">  </span><span class="nt">cache</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;FILESYSTEM&quot;</span><span class="w"></span>
<span class="w">    </span><span class="nt">config</span><span class="p">:</span><span class="w"></span>
<span class="w">      </span><span class="nt">directory</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;./tmp&quot;</span><span class="w"></span>

<span class="nt">scrape_configs</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">job_name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;bookstore&quot;</span><span class="w"></span>
<span class="w">    </span><span class="nt">scrape_interval</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;1m&quot;</span><span class="w"></span>
<span class="w">    </span><span class="nt">scrape_timeout</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;15s&quot;</span><span class="w"></span>
<span class="w">    </span><span class="nt">static_configs</span><span class="p">:</span><span class="w"></span>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">targets</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="w"> </span><span class="s">&#39;bookstore.default:6060&#39;</span><span class="w"> </span><span class="p p-Indicator">]</span><span class="w"></span>
</code></pre></div>

<p>Note, the config above is part of
<a href="https://github.com/parca-dev/parca/releases/download/v0.10.0/kubernetes-manifest.yaml">kubernetes-manifest.yaml</a>.
Check out <a href="https://www.parca.dev/docs/kubernetes">Parca tutorial</a> to learn more.</p>
<h2>BPF profiling agent</h2>
<p>The cool things about BPF profiling agents are that they incur low overhead,
can capture user/kernel-space stack traces, and don't need much configuration
because they discover containers on the Kubernetes node where an agent is running.</p>
<p>A quick summary about BPF.
In the kernel, a BPF program is executed on each event.
The event types could be kprobes, uprobes, tracepoints, sockets, perf_events.
It can use BPF helpers to fetch kernel state, and BPF maps for storage.
In user space BPF maps or a perf buffer are periodically read and some output (summary) is shown to a user.</p>
<p>I was curious how Parca Agent was implemented.
According to its <a href="https://github.com/parca-dev/parca-agent/blob/main/docs/design.md">design doc</a>
it attaches the BPF program to a Linux cgroup using
<a href="https://man7.org/linux/man-pages/man2/perf_event_open.2.html">perf_event_open()</a> system call.
The call creates a file descriptor that allows measuring performance information.
It instructs the kernel to call the BPF program 100 times per second.</p>
<p>Here I annotated
<a href="https://github.com/parca-dev/parca-agent/blob/1e935f4d5f7b4484f6cf3d4ee26340f3718ff37d/pkg/profiler/profiler.go#L270">github.com/parca-dev/parca-agent/pkg/profiler/profiler.go</a> code around the syscall.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// To discover cgroups to profile in Kubernetes,</span><span class="w"></span>
<span class="c1">// Parca Agent first discovers all pods running on the node it is on,</span><span class="w"></span>
<span class="c1">// then discovers the primary PID of the cgroup using Kubernetes CRI (container runtime interface).</span><span class="w"></span>
<span class="c1">// For profiling purposes a perf_event cgroup is required, which is read from /proc/PID/cgroup.</span><span class="w"></span>
<span class="nx">cgroup</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="o">...</span><span class="p">)</span><span class="w"></span>
<span class="c1">// The pid and cpu arguments allow specifying which process and CPU to monitor.</span><span class="w"></span>
<span class="nx">pid</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">int</span><span class="p">(</span><span class="nx">cgroup</span><span class="p">.</span><span class="nx">Fd</span><span class="p">())</span><span class="w"></span>

<span class="k">for</span><span class="w"> </span><span class="nx">cpu</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">cpu</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">runtime</span><span class="p">.</span><span class="nx">NumCPU</span><span class="p">();</span><span class="w"> </span><span class="nx">cpu</span><span class="o">++</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">fd</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">unix</span><span class="p">.</span><span class="nx">PerfEventOpen</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="o">&amp;</span><span class="nx">unix</span><span class="p">.</span><span class="nx">PerfEventAttr</span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// PERF_TYPE_SOFTWARE event type indicates that</span><span class="w"></span>
<span class="w">            </span><span class="c1">// we are measuring software events provided by the kernel.</span><span class="w"></span>
<span class="w">            </span><span class="nx">Type</span><span class="p">:</span><span class="w"> </span><span class="nx">unix</span><span class="p">.</span><span class="nx">PERF_TYPE_SOFTWARE</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="c1">// Config is a Type-specific configuration.</span><span class="w"></span>
<span class="w">            </span><span class="c1">// PERF_COUNT_SW_CPU_CLOCK reports the CPU clock, a high-resolution per-CPU timer.</span><span class="w"></span>
<span class="w">            </span><span class="nx">Config</span><span class="p">:</span><span class="w"> </span><span class="nx">unix</span><span class="p">.</span><span class="nx">PERF_COUNT_SW_CPU_CLOCK</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="c1">// Size of attribute structure for forward/backward compatibility.</span><span class="w"></span>
<span class="w">            </span><span class="nx">Size</span><span class="p">:</span><span class="w"> </span><span class="nb">uint32</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Sizeof</span><span class="p">(</span><span class="nx">unix</span><span class="p">.</span><span class="nx">PerfEventAttr</span><span class="p">{})),</span><span class="w"></span>
<span class="w">            </span><span class="c1">// Sample could mean sampling period (expressed as the number of occurrences of an event)</span><span class="w"></span>
<span class="w">            </span><span class="c1">// or frequency (the average rate of samples per second).</span><span class="w"></span>
<span class="w">            </span><span class="c1">// See https://perf.wiki.kernel.org/index.php/Tutorial#Period_and_rate.</span><span class="w"></span>
<span class="w">            </span><span class="c1">// In order to use frequency PerfBitFreq flag is set below.</span><span class="w"></span>
<span class="w">            </span><span class="c1">// The kernel will adjust the sampling period to try and achieve the desired rate.</span><span class="w"></span>
<span class="w">            </span><span class="nx">Sample</span><span class="p">:</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="nx">Bits</span><span class="p">:</span><span class="w"> </span><span class="nx">unix</span><span class="p">.</span><span class="nx">PerfBitDisabled</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">unix</span><span class="p">.</span><span class="nx">PerfBitFreq</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">},</span><span class="w"></span>
<span class="w">        </span><span class="nx">pid</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="nx">cpu</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="c1">// This argument allows event groups to be created.</span><span class="w"></span>
<span class="w">        </span><span class="c1">// A single event on its own is created with groupFd = -1</span><span class="w"></span>
<span class="w">        </span><span class="c1">// and is considered to be a group with only 1 member.</span><span class="w"></span>
<span class="w">        </span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="c1">// PERF_FLAG_PID_CGROUP flag activates per-container system-wide monitoring.</span><span class="w"></span>
<span class="w">        </span><span class="c1">// In this mode, the event is measured only if the thread running on the monitored CPU</span><span class="w"></span>
<span class="w">        </span><span class="c1">// belongs to the designated container (cgroup).</span><span class="w"></span>
<span class="w">        </span><span class="nx">unix</span><span class="p">.</span><span class="nx">PERF_FLAG_PID_CGROUP</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<h3>BPF C code</h3>
<p>From looking at BPF C code
<a href="https://github.com/parca-dev/parca-agent/blob/31253527651ebebb74c6200eb68fe9251479ed6b/parca-agent.bpf.c">parca-agent.bpf.c</a>
we can see the BPF program <code>do_sample</code>.
As mentioned above it's executed 100 times per second.
Each time it captures stack traces of the thread that is currently running on CPU.</p>
<div class="highlight"><pre><span></span><code><span class="n">SEC</span><span class="p">(</span><span class="s">&quot;perf_event&quot;</span><span class="p">)</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">do_sample</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">bpf_perf_event_data</span><span class="w"> </span><span class="o">*</span><span class="n">ctx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</code></pre></div>

<p><code>SEC("perf_event")</code> denotes <code>BPF_PROG_TYPE_PERF_EVENT</code> BPF program type
which specifies the type of events that the BPF program attaches to (perf_events),
and the arguments for the events.</p>
<div class="highlight"><pre><span></span><code><span class="n">u64</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bpf_get_current_pid_tgid</span><span class="p">();</span><span class="w"></span>
<span class="n">u32</span><span class="w"> </span><span class="n">tgid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"></span>
<span class="n">u32</span><span class="w"> </span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">id</span><span class="p">;</span><span class="w"></span>
</code></pre></div>

<p><a href="https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/bpf.h#L1777">bpf_get_current_pid_tgid()</a>
BPF helper returns an unsigned 64-bit integer containing
the current TGID (what user space calls the PID) in the upper bits and
the current PID (what user space calls the kernel thread ID) in the lower bits.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Max amount of different stack trace addresses to buffer in the map.</span>
<span class="cp">#define MAX_STACK_ADDRESSES 1024</span>
<span class="c1">// Max depth of each stack trace to track.</span>
<span class="cp">#define MAX_STACK_DEPTH 127</span>
<span class="c1">// Stack trace value is 1 big byte array of the stack addresses.</span>
<span class="k">typedef</span><span class="w"> </span><span class="n">__u64</span><span class="w"> </span><span class="n">stack_trace_type</span><span class="p">[</span><span class="n">MAX_STACK_DEPTH</span><span class="p">];</span><span class="w"></span>

<span class="c1">// The stack_traces map holds an array of memory addresses,</span>
<span class="c1">// e.g., stack_traces[1253] = [0xdeadbeef, 0x123abcde]</span>
<span class="c1">// where 1253 is a stack ID.</span>
<span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">__uint</span><span class="p">(</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">BPF_MAP_TYPE_STACK_TRACE</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">__uint</span><span class="p">(</span><span class="n">max_entries</span><span class="p">,</span><span class="w"> </span><span class="n">MAX_STACK_ADDRESSES</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">__type</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">u32</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">__type</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">stack_trace_type</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">stack_traces</span><span class="w"> </span><span class="n">SEC</span><span class="p">(</span><span class="s">&quot;.maps&quot;</span><span class="p">);</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="nc">stack_count_key_t</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">u32</span><span class="w"> </span><span class="n">pid</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">int32</span><span class="w"> </span><span class="n">user_stack_id</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">int32</span><span class="w"> </span><span class="n">kernel_stack_id</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="c1">// The counts map keeps track of how many times a stack trace has been seen,</span>
<span class="c1">// e.g., counts[{10342, 1253, 0234}] = 45 times.</span>
<span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">__uint</span><span class="p">(</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">BPF_MAP_TYPE_HASH</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">__uint</span><span class="p">(</span><span class="n">max_entries</span><span class="p">,</span><span class="w"> </span><span class="mi">10240</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">__type</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">stack_count_key_t</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">__type</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">u64</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">counts</span><span class="w"> </span><span class="n">SEC</span><span class="p">(</span><span class="s">&quot;.maps&quot;</span><span class="p">);</span><span class="w"></span>
</code></pre></div>

<p>The BPF program records stack traces in special <code>stack_traces</code> BPF map
which is indexed by stack IDs.
The map value is an array of memory addresses that represent the code executed.</p>
<table>
<thead>
<tr>
<th>stack ID</th>
<th>memory addresses</th>
</tr>
</thead>
<tbody>
<tr>
<td>1253</td>
<td>[ 0xdeadbeef; 0x123abcde; ... ]</td>
</tr>
<tr>
<td>0234</td>
<td>[ 0x597be95a; 0xae5ee03; ... ]</td>
</tr>
</tbody>
</table>
<p>The <code>counts</code> BPF map keeps track of how many times a stack trace has been seen:</p>
<ul>
<li>its key is a triple of PID, user-space stack ID, and kernel-space stack ID, see <code>struct stack_count_key_t { ... }</code></li>
<li>its value is the amount of times that stack trace has been observed</li>
</ul>
<table>
<thead>
<tr>
<th>stack_count_key_t</th>
<th>seen</th>
</tr>
</thead>
<tbody>
<tr>
<td>{ 10342; 1253; 0234 }</td>
<td>45</td>
</tr>
</tbody>
</table>
<p>The maps are populated using
<a href="https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/bpf.h#L2080">bpf_get_stackid()</a>
and <code>bpf_map_lookup_or_try_init()</code> functions.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Create a key for &quot;counts&quot; map.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">stack_count_key_t</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{.</span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tgid</span><span class="p">};</span><span class="w"></span>
<span class="c1">// Read user-space stack ID and insert memory addresses into stack_traces map.</span>
<span class="c1">// The positive or null stack id is returned on success,</span>
<span class="c1">// or a negative error in case of failure.</span>
<span class="n">key</span><span class="p">.</span><span class="n">user_stack_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bpf_get_stackid</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">stack_traces</span><span class="p">,</span><span class="w"> </span><span class="n">BPF_F_USER_STACK</span><span class="p">);</span><span class="w"></span>
<span class="c1">// Read kernel-space stack ID and insert memory addresses into stack_traces map.</span>
<span class="n">key</span><span class="p">.</span><span class="n">kernel_stack_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bpf_get_stackid</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">stack_traces</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="n">u64</span><span class="w"> </span><span class="n">zero</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="n">u64</span><span class="w"> </span><span class="o">*</span><span class="n">seen</span><span class="p">;</span><span class="w"></span>
<span class="n">seen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bpf_map_lookup_or_try_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">counts</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">zero</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">seen</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="c1">// Atomically increments the seen counter.</span>
<span class="n">__sync_fetch_and_add</span><span class="p">(</span><span class="n">seen</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
</code></pre></div>

<p>On Go side the BPF maps are read every 10 seconds,
get processed, and then purged to reset for the next iteration.</p>
<h3>DIY profiler</h3>
<p>Parca Agent relies on <a href="https://github.com/aquasecurity/libbpfgo">cgo bindings for libbpf</a> from Aqua Security.
I wanted to make something similar using
<a href="https://github.com/cilium/ebpf">github.com/cilium/ebpf</a> which doesn't need cgo.</p>
<p>In order to prepare the environment I ran Ubuntu 21.10 in a virtual machine and installed Clang with Go.</p>
<div class="highlight"><pre><span></span><code><span class="go">ï¹ª cat &gt; Vagrantfile &lt;&lt;CFG</span>
<span class="go">Vagrant.configure(&quot;2&quot;) do |config|</span>
<span class="go">    config.vm.box = &quot;ubuntu/impish64&quot;</span>
<span class="go">end</span>
<span class="go">CFG</span>
<span class="go">ï¹ª vagrant up</span>
<span class="go">ï¹ª vagrant ssh</span>
<span class="go">ï¹© sudo apt-get update</span>
<span class="go">ï¹© sudo apt-get install clang</span>
<span class="go">ï¹© sudo snap install go --classic</span>
<span class="go">ï¹© uname -nr</span>
<span class="go">ubuntu-impish 5.13.0-39-generic</span>
<span class="go">ï¹© clang -v</span>
<span class="go">Ubuntu clang version 13.0.0-2</span>
</code></pre></div>

<p>Then I copied
<a href="https://github.com/parca-dev/parca-agent/blob/31253527651ebebb74c6200eb68fe9251479ed6b/parca-agent.bpf.c">parca-agent.bpf.c</a>
from parca-agent repository and tried to generate Go files using bpf2go tool.</p>
<div class="highlight"><pre><span></span><code><span class="go">ï¹© cd /vagrant/</span>
<span class="go">ï¹© mkdir -p cmd/profiler/bpf/</span>
<span class="go">ï¹© curl -o cmd/profiler/bpf/parca-agent.bpf.c https://raw.githubusercontent.com/parca-dev/parca-agent/31253527651ebebb74c6200eb68fe9251479ed6b/parca-agent.bpf.c</span>
<span class="go">ï¹© cat &gt; cmd/profiler/main.go &lt;&lt;&lt;&#39;&#39;&#39;</span>
<span class="go">package main</span>

<span class="go">//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -cflags $BPF_CFLAGS -cc clang-13 ParcaAgent ./bpf/parca-agent.bpf.c -- -I../../headers</span>

<span class="go">func main() {}</span>
<span class="go">&#39;&#39;&#39;</span>
<span class="go">ï¹© go mod init diy-parca-agent</span>
<span class="go">ï¹© go get github.com/cilium/ebpf/cmd/bpf2go</span>
<span class="go">ï¹© go generate ./cmd/profiler/</span>
<span class="go">/vagrant/cmd/profiler/bpf/parca-agent.bpf.c:11:10: fatal error: &#39;vmlinux.h&#39; file not found</span>
</code></pre></div>

<p><code>vmlinux.h</code> can be generated from the installed kernel using bpftool tool.</p>
<div class="highlight"><pre><span></span><code><span class="go">ï¹© mkdir headers</span>
<span class="go">ï¹© sudo apt-get install linux-tools-$(uname -r) linux-tools-common</span>
<span class="go">ï¹© bpftool btf dump file /sys/kernel/btf/vmlinux format c &gt; ./headers/vmlinux.h</span>
</code></pre></div>

<p>The remaining missing headers I copied from ubuntu-kernel, libbpf, and cilium repositories.</p>
<div class="highlight"><pre><span></span><code><span class="go">ï¹© curl -o ./headers/bpf_core_read.h https://git.launchpad.net/~ubuntu-kernel/ubuntu/+source/linux/+git/impish/plain/tools/lib/bpf/bpf_core_read.h</span>
<span class="go">ï¹© curl -o ./headers/bpf_endian.h https://raw.githubusercontent.com/cilium/ebpf/master/examples/headers/bpf_endian.h</span>
<span class="go">ï¹© curl -o ./headers/bpf_helpers.h https://git.launchpad.net/~ubuntu-kernel/ubuntu/+source/linux/+git/impish/plain/tools/lib/bpf/bpf_helpers.h</span>
<span class="go">ï¹© curl -o ./headers/bpf_tracing.h https://git.launchpad.net/~ubuntu-kernel/ubuntu/+source/linux/+git/impish/plain/tools/lib/bpf/bpf_tracing.h</span>
<span class="go">ï¹© curl -o ./headers/bpf_helper_defs.h https://raw.githubusercontent.com/libbpf/libbpf/master/src/bpf_helper_defs.h</span>
</code></pre></div>

<p>Finally, all the dependencies were resolved and Go code was generated.</p>
<div class="highlight"><pre><span></span><code><span class="go">ï¹© go generate ./cmd/profiler/</span>
<span class="go">Compiled /vagrant/cmd/profiler/parcaagent_bpfel.o</span>
<span class="go">Stripped /vagrant/cmd/profiler/parcaagent_bpfel.o</span>
<span class="go">Wrote /vagrant/cmd/profiler/parcaagent_bpfel.go</span>
<span class="go">Compiled /vagrant/cmd/profiler/parcaagent_bpfeb.o</span>
<span class="go">Stripped /vagrant/cmd/profiler/parcaagent_bpfeb.o</span>
<span class="go">Wrote /vagrant/cmd/profiler/parcaagent_bpfeb.go</span>
</code></pre></div>

<p>Next step was to see whether <code>DoSample</code> BPF program is loaded into the kernel from an ELF.
<code>ParcaAgentObjects{}</code> contains all objects (BPF program and BPF maps) after they have been loaded into the kernel.</p>
<div class="highlight"><pre><span></span><code><span class="nx">objs</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">ParcaAgentObjects</span><span class="p">{}</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">LoadParcaAgentObjects</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">objs</span><span class="p">,</span><span class="w"> </span><span class="kc">nil</span><span class="p">);</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">log</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;failed to load BPF program and maps: %v&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">defer</span><span class="w"> </span><span class="nx">objs</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span><span class="w"></span>
</code></pre></div>

<p>It worked, no errors were printed.</p>
<div class="highlight"><pre><span></span><code><span class="go">ï¹© sudo go run ./cmd/profiler/</span>
</code></pre></div>

<blockquote>
<p>A call to perf_event_open() creates a file descriptor
that allows measuring performance information.
Each file descriptor corresponds to one event that is measured.
Events can be enabled and disabled via ioctl(2).
https://man7.org/linux/man-pages/man2/perf_event_open.2.html</p>
</blockquote>
<p>It's time to attach <code>DoSample</code> BPF program to perf event using
<code>unix.PerfEventOpen()</code> and <code>unix.IoctlSetInt()</code> functions.
Note, Parca Agent doesn't directly use <code>unix.IoctlSetInt()</code> and relies on
<a href="https://pkg.go.dev/github.com/aquasecurity/libbpfgo#BPFProg.AttachPerfEvent">AttachPerfEvent()</a>
function from <a href="http://github.com/aquasecurity/libbpfgo">github.com/aquasecurity/libbpfgo</a>.
I found cilium related explanation <a href="https://github.com/cilium/ebpf/discussions/548">#548</a>
how to achieve the same thing:</p>
<ol>
<li>Load the BPF program into the kernel: <code>LoadParcaAgentObjects(&amp;objs, nil)</code></li>
<li>Open the perf event: <code>fd, _ := unix.PerfEventOpen(...)</code>.</li>
<li>Set the BPF program on the perf event:
  <code>unix.IoctlSetInt(fd, unix.PERF_EVENT_IOC_SET_BPF, objs.DoSample.FD())</code></li>
<li>Enable the perf event:
   <code>unix.IoctlSetInt(fd, unix.PERF_EVENT_IOC_ENABLE, 0)</code></li>
</ol>
<p>Those steps worked as well.
I was hopeful to see whether stack traces were collected,
so I periodically printed the content of <code>Counts</code> BPF map.</p>
<div class="highlight"><pre><span></span><code><span class="kd">type</span><span class="w"> </span><span class="nx">stackCountKey</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">PID</span><span class="w">           </span><span class="kt">uint32</span><span class="w"></span>
<span class="w">    </span><span class="nx">UserStackID</span><span class="w">   </span><span class="kt">int32</span><span class="w"></span>
<span class="w">    </span><span class="nx">KernelStackID</span><span class="w"> </span><span class="kt">int32</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">var</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="nx">key</span><span class="w">   </span><span class="nx">stackCountKey</span><span class="w"></span>
<span class="w">    </span><span class="nx">value</span><span class="w"> </span><span class="kt">uint64</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
<span class="nx">it</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">objs</span><span class="p">.</span><span class="nx">ParcaAgentMaps</span><span class="p">.</span><span class="nx">Counts</span><span class="p">.</span><span class="nx">Iterate</span><span class="p">()</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="nx">it</span><span class="p">.</span><span class="nx">Next</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">key</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%+v seen %d times\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">key</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">it</span><span class="p">.</span><span class="nx">Err</span><span class="p">();</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">log</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;failed to read from Counts map: %v&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>The easiest way to reliably get stack traces was to run <code>top</code> in another terminal.
I made the profiler focus on its PID 15958 and it worked ðŸŽ‰.</p>
<div class="highlight"><pre><span></span><code><span class="go">ï¹© top</span>
<span class="go">ï¹© sudo go run ./cmd/profiler/ -pid 15958</span>
<span class="go">Waiting for stack traces...</span>
<span class="go">{PID:15958 UserStackID:132 KernelStackID:114} seen 1 times</span>
<span class="go">{PID:15958 UserStackID:709 KernelStackID:-14} seen 1 times # -14 indicates bpf_get_stackid() error.</span>
<span class="go">{PID:15958 UserStackID:366 KernelStackID:30} seen 2 times</span>
<span class="go">{PID:15958 UserStackID:674 KernelStackID:943} seen 1 times</span>
</code></pre></div>

<p>The end of my post is an disappointing anticlimax because
I haven't looked yet at how to show the actual stack traces.
I will update <a href="https://github.com/marselester/diy-parca-agent">the repository</a> when I have time.</p>
<p>Update: finally I figured out how to show stack traces, see
<a href="https://marselester.com/diy-cpu-profiler-from-bpf-maps-to-pprof.html">DIY CPU profiler: from BPF maps to pprof</a> post.</p>
<p class="subheader">Category: <a href="https://marselester.com/category/go.html">Go</a>

    Tagged: 
    <a href="https://marselester.com/tag/bpf.html">bpf </a>
    <a href="https://marselester.com/tag/golang.html">golang </a>
    <a href="https://marselester.com/tag/monitoring.html">monitoring </a>
</p>




	<h4>Comments</h4>
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'marselester'
        var disqus_identifier = "continuous-profiling-in-go.html";
        var disqus_url = "https://marselester.com/continuous-profiling-in-go.html";

        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</article>
    </div>
    <!-- End Main Content -->

    <!-- Sidebar -->
    <aside class="large-3 columns">
        <h5 class="sidebar-title">Site</h5>
        <ul class="side-nav">
            <li><a href="https://marselester.com/archives.html">Archives</a>
            <li><a href="https://marselester.com/tags.html">Tags</a>


                <li><a href="https://marselester.com/feeds/all.atom.xml" rel="alternate">Atom feed</a></li>
        </ul>

		
        <h5 class="sidebar-title">Categories</h5>
        <ul class="side-nav">
            <li><a href="https://marselester.com/category/go.html">Go</a></li>
            <li><a href="https://marselester.com/category/infrastructure.html">Infrastructure</a></li>
            <li><a href="https://marselester.com/category/misc.html">Misc</a></li>
            <li><a href="https://marselester.com/category/performance.html">Performance</a></li>
            <li><a href="https://marselester.com/category/python.html">Python</a></li>
   
        </ul>

		
        <h5 class="sidebar-title">Social</h5>
        <ul class="side-nav">
            <li><a href="https://github.com/marselester">GitHub</a></li>
            <li><a href="https://www.instagram.com/marselester/">Instagram ðŸ“·</a></li>
            <li><a href="http://twitter.com/marselester">Twitter</a></li>
            <li><a href="https://medium.com/@marselester/">Medium</a></li>
        </ul>

    </aside> <!-- End Sidebar -->

</div> <!-- End Main Content and Sidebar -->


<!-- Footer -->
<footer class="row">
    <div class="large-12 columns">
        <hr />
        <div class="row">
            <div class="large-6 columns">
                <p>marselester's blog by Marsel Mavletkulov</p>
            </div>
            </div>
    </div>
</footer>