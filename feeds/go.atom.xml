<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>marselester's blog - Go</title><link href="https://marselester.com/" rel="alternate"></link><link href="https://marselester.com/feeds/go.atom.xml" rel="self"></link><id>https://marselester.com/</id><updated>2022-04-22T00:00:00+07:00</updated><entry><title>Continuous profiling in Go</title><link href="https://marselester.com/continuous-profiling-in-go.html" rel="alternate"></link><published>2022-04-22T00:00:00+07:00</published><updated>2022-04-22T00:00:00+07:00</updated><author><name>Marsel Mavletkulov</name></author><id>tag:marselester.com,2022-04-22:/continuous-profiling-in-go.html</id><summary type="html">&lt;p&gt;In this post I explore possibilities of continuous profiling of Go programs
using Parca and also peek under the hood of its BPF agent.
You can find the results of my experiments in
&lt;a href="https://github.com/marselester/diy-parca-agent"&gt;github.com/marselester/diy-parca-agent&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Ad hoc profiling&lt;/h2&gt;
&lt;p&gt;I was looking for a way to profile Go programs â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;In this post I explore possibilities of continuous profiling of Go programs
using Parca and also peek under the hood of its BPF agent.
You can find the results of my experiments in
&lt;a href="https://github.com/marselester/diy-parca-agent"&gt;github.com/marselester/diy-parca-agent&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Ad hoc profiling&lt;/h2&gt;
&lt;p&gt;I was looking for a way to profile Go programs running in Kubernetes
to see where a program spends its CPU time (which functions consume most CPU)
or where memory allocations happen.
Allocations in a frequently called function could cause GC pressure
which in turn could cause latency spikes in HTTP requests.&lt;/p&gt;
&lt;p&gt;Latency of the Bookstore service is taken seriously,
so its API server already had &lt;code&gt;import _ "net/http/pprof"&lt;/code&gt; to enable profiling with &lt;code&gt;go tool pprof&lt;/code&gt; program.
In order to get access to the HTTP server running in the pod
a port forwarder could be used.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;ï¹© kubectl get pods -A | grep bookstore&lt;/span&gt;
&lt;span class="go"&gt;default                  bookstore-574897d6-e18e&lt;/span&gt;
&lt;span class="go"&gt;ï¹© kubectl port-forward -n default bookstore-574897d6-e18e 6060 &amp;amp;&lt;/span&gt;
&lt;span class="go"&gt;Forwarding from 127.0.0.1:6060 -&amp;gt; 6060&lt;/span&gt;
&lt;span class="go"&gt;Forwarding from [::1]:6060 -&amp;gt; 6060&lt;/span&gt;
&lt;span class="go"&gt;ï¹© fg 1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The following URLs under &lt;code&gt;/debug/pprof/&lt;/code&gt; provide profiling data.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;ï¼ƒ 30-second CPU profile.&lt;/span&gt;
&lt;span class="go"&gt;ï¹© curl http://0.0.0.0:6060/debug/pprof/profile --output ./cpu.pprof&lt;/span&gt;
&lt;span class="go"&gt;ï¼ƒ Heap allocations profile since the process started&lt;/span&gt;
&lt;span class="go"&gt;ï¼ƒ including garbage-collected bytes (useful when optimising code).&lt;/span&gt;
&lt;span class="go"&gt;ï¹© curl http://0.0.0.0:6060/debug/pprof/allocs --output ./heap-all.pprof&lt;/span&gt;
&lt;span class="go"&gt;ï¼ƒ Heap allocations of live objects (useful when looking for memory leaks).&lt;/span&gt;
&lt;span class="go"&gt;ï¹© curl http://0.0.0.0:6060/debug/pprof/heap --output ./heap-live.pprof&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In order to inspect the heap profile &lt;code&gt;heap-all.pprof&lt;/code&gt;
I would need to compile the API &lt;code&gt;server&lt;/code&gt; program and fix the search path for source files:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;source_path&lt;/code&gt; is an absolute path to your source code (the Bookstore's git repository),
  e.g., on Mac it could be &lt;code&gt;/Users/bob/code/bookstore/&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;trim_path&lt;/code&gt; is a path the profile expects the code to be at, e.g.,
  &lt;code&gt;/opt/bookstore/&lt;/code&gt; because the binary was compiled in Docker by CI/CD&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;ï¹© GOOS=linux go build ./cmd/server/&lt;/span&gt;
&lt;span class="go"&gt;ï¹© go tool pprof -source_path=&amp;quot;$(pwd)&amp;quot; -trim_path=/opt/bookstore/ ./server ./heap-all.pprof&lt;/span&gt;
&lt;span class="go"&gt;ï¹ª web&lt;/span&gt;
&lt;span class="go"&gt;ï¹ª top10 -cum&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code&gt;web&lt;/code&gt; command opens an allocation graph of function calls.
The &lt;code&gt;top10 -cum&lt;/code&gt; command shows top ten functions by allocations in that function
or a function it called (cumulative) down the stack:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;flat&lt;/code&gt; is a memory allocated by that function and is held by it&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cum&lt;/code&gt; is a memory allocated by that function or a function it called down the stack.
  When &lt;code&gt;flat&lt;/code&gt; and &lt;code&gt;cum&lt;/code&gt; numbers match,
  this might indicate the allocated memory is retained.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Continuous profiling&lt;/h2&gt;
&lt;p&gt;I could be lucky and discover some obvious problem,
though most likely by the time the profiles are collected it is already too late
because a Kubernetes pod in question is already gone.&lt;/p&gt;
&lt;p&gt;A continuous profiler could have collected the data
when a problem was occuring on production,
so I was curious to see what open source tooling is available.
Here is what I found so far:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.parca.dev/"&gt;Parca&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://pyroscope.io/"&gt;Pyroscope&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/profefe/profefe"&gt;profefe&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All of them are capable, moreover Parca and Pyroscope have BPF agents.
I experimented with Parca more because I stumbled on it earlier.
So here is how Parca Server configuration looked like
when I set it up to collect profiles every minute from the Bookstore service.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nt"&gt;debug_info&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="nt"&gt;bucket&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="nt"&gt;type&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;FILESYSTEM&amp;quot;&lt;/span&gt;
    &lt;span class="nt"&gt;config&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
      &lt;span class="nt"&gt;directory&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;./tmp&amp;quot;&lt;/span&gt;
  &lt;span class="nt"&gt;cache&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="nt"&gt;type&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;FILESYSTEM&amp;quot;&lt;/span&gt;
    &lt;span class="nt"&gt;config&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
      &lt;span class="nt"&gt;directory&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;./tmp&amp;quot;&lt;/span&gt;

&lt;span class="nt"&gt;scrape_configs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;job_name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;bookstore&amp;quot;&lt;/span&gt;
    &lt;span class="nt"&gt;scrape_interval&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;1m&amp;quot;&lt;/span&gt;
    &lt;span class="nt"&gt;scrape_timeout&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;15s&amp;quot;&lt;/span&gt;
    &lt;span class="nt"&gt;static_configs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
      &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;targets&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p p-Indicator"&gt;[&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;bookstore.default:6060&amp;#39;&lt;/span&gt; &lt;span class="p p-Indicator"&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Note, the config above is part of
&lt;a href="https://github.com/parca-dev/parca/releases/download/v0.10.0/kubernetes-manifest.yaml"&gt;kubernetes-manifest.yaml&lt;/a&gt;.
Check out &lt;a href="https://www.parca.dev/docs/kubernetes"&gt;Parca tutorial&lt;/a&gt; to learn more.&lt;/p&gt;
&lt;h2&gt;BPF profiling agent&lt;/h2&gt;
&lt;p&gt;The cool things about BPF profiling agents are that they incur low overhead,
can capture user/kernel-space stack traces, and don't need much configuration
because they discover containers on the Kubernetes node where an agent is running.&lt;/p&gt;
&lt;p&gt;A quick summary about BPF.
In the kernel, a BPF program is executed on each event.
The event types could be kprobes, uprobes, tracepoints, sockets, perf_events.
It can use BPF helpers to fetch kernel state, and BPF maps for storage.
In user space BPF maps or a perf buffer are periodically read and some output (summary) is shown to a user.&lt;/p&gt;
&lt;p&gt;I was curious how Parca Agent was implemented.
According to its &lt;a href="https://github.com/parca-dev/parca-agent/blob/main/docs/design.md"&gt;design doc&lt;/a&gt;
it attaches the BPF program to a Linux cgroup using
&lt;a href="https://man7.org/linux/man-pages/man2/perf_event_open.2.html"&gt;perf_event_open()&lt;/a&gt; system call.
The call creates a file descriptor that allows measuring performance information.
It instructs the kernel to call the BPF program 100 times per second.&lt;/p&gt;
&lt;p&gt;Here I annotated
&lt;a href="https://github.com/parca-dev/parca-agent/blob/1e935f4d5f7b4484f6cf3d4ee26340f3718ff37d/pkg/profiler/profiler.go#L270"&gt;github.com/parca-dev/parca-agent/pkg/profiler/profiler.go&lt;/a&gt; code around the syscall.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// To discover cgroups to profile in Kubernetes,&lt;/span&gt;
&lt;span class="c1"&gt;// Parca Agent first discovers all pods running on the node it is on,&lt;/span&gt;
&lt;span class="c1"&gt;// then discovers the primary PID of the cgroup using Kubernetes CRI (container runtime interface).&lt;/span&gt;
&lt;span class="c1"&gt;// For profiling purposes a perf_event cgroup is required, which is read from /proc/PID/cgroup.&lt;/span&gt;
&lt;span class="nx"&gt;cgroup&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;// The pid and cpu arguments allow specifying which process and CPU to monitor.&lt;/span&gt;
&lt;span class="nx"&gt;pid&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;cgroup&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Fd&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;cpu&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;cpu&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nx"&gt;runtime&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;NumCPU&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="nx"&gt;cpu&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;unix&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;PerfEventOpen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;unix&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;PerfEventAttr&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="c1"&gt;// PERF_TYPE_SOFTWARE event type indicates that&lt;/span&gt;
            &lt;span class="c1"&gt;// we are measuring software events provided by the kernel.&lt;/span&gt;
            &lt;span class="nx"&gt;Type&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;unix&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;PERF_TYPE_SOFTWARE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="c1"&gt;// Config is a Type-specific configuration.&lt;/span&gt;
            &lt;span class="c1"&gt;// PERF_COUNT_SW_CPU_CLOCK reports the CPU clock, a high-resolution per-CPU timer.&lt;/span&gt;
            &lt;span class="nx"&gt;Config&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;unix&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;PERF_COUNT_SW_CPU_CLOCK&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="c1"&gt;// Size of attribute structure for forward/backward compatibility.&lt;/span&gt;
            &lt;span class="nx"&gt;Size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;uint32&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;unsafe&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;unix&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;PerfEventAttr&lt;/span&gt;&lt;span class="p"&gt;{})),&lt;/span&gt;
            &lt;span class="c1"&gt;// Sample could mean sampling period (expressed as the number of occurrences of an event)&lt;/span&gt;
            &lt;span class="c1"&gt;// or frequency (the average rate of samples per second).&lt;/span&gt;
            &lt;span class="c1"&gt;// See https://perf.wiki.kernel.org/index.php/Tutorial#Period_and_rate.&lt;/span&gt;
            &lt;span class="c1"&gt;// In order to use frequency PerfBitFreq flag is set below.&lt;/span&gt;
            &lt;span class="c1"&gt;// The kernel will adjust the sampling period to try and achieve the desired rate.&lt;/span&gt;
            &lt;span class="nx"&gt;Sample&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="nx"&gt;Bits&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;unix&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;PerfBitDisabled&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="nx"&gt;unix&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;PerfBitFreq&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="p"&gt;},&lt;/span&gt;
        &lt;span class="nx"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;cpu&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="c1"&gt;// This argument allows event groups to be created.&lt;/span&gt;
        &lt;span class="c1"&gt;// A single event on its own is created with groupFd = -1&lt;/span&gt;
        &lt;span class="c1"&gt;// and is considered to be a group with only 1 member.&lt;/span&gt;
        &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="c1"&gt;// PERF_FLAG_PID_CGROUP flag activates per-container system-wide monitoring.&lt;/span&gt;
        &lt;span class="c1"&gt;// In this mode, the event is measured only if the thread running on the monitored CPU&lt;/span&gt;
        &lt;span class="c1"&gt;// belongs to the designated container (cgroup).&lt;/span&gt;
        &lt;span class="nx"&gt;unix&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;PERF_FLAG_PID_CGROUP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;BPF C code&lt;/h3&gt;
&lt;p&gt;From looking at BPF C code
&lt;a href="https://github.com/parca-dev/parca-agent/blob/31253527651ebebb74c6200eb68fe9251479ed6b/parca-agent.bpf.c"&gt;parca-agent.bpf.c&lt;/a&gt;
we can see the BPF program &lt;code&gt;do_sample&lt;/code&gt;.
As mentioned above it's executed 100 times per second.
Each time it captures stack traces of the thread that is currently running on CPU.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;SEC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;perf_event&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;do_sample&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;bpf_perf_event_data&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;SEC("perf_event")&lt;/code&gt; denotes &lt;code&gt;BPF_PROG_TYPE_PERF_EVENT&lt;/code&gt; BPF program type
which specifies the type of events that the BPF program attaches to (perf_events),
and the arguments for the events.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;u64&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bpf_get_current_pid_tgid&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;u32&lt;/span&gt; &lt;span class="n"&gt;tgid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;u32&lt;/span&gt; &lt;span class="n"&gt;pid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href="https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/bpf.h#L1777"&gt;bpf_get_current_pid_tgid()&lt;/a&gt;
BPF helper returns an unsigned 64-bit integer containing
the current TGID (what user space calls the PID) in the upper bits and
the current PID (what user space calls the kernel thread ID) in the lower bits.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// Max amount of different stack trace addresses to buffer in the map.&lt;/span&gt;
&lt;span class="cp"&gt;#define MAX_STACK_ADDRESSES 1024&lt;/span&gt;
&lt;span class="c1"&gt;// Max depth of each stack trace to track.&lt;/span&gt;
&lt;span class="cp"&gt;#define MAX_STACK_DEPTH 127&lt;/span&gt;
&lt;span class="c1"&gt;// Stack trace value is 1 big byte array of the stack addresses.&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;__u64&lt;/span&gt; &lt;span class="n"&gt;stack_trace_type&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;MAX_STACK_DEPTH&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="c1"&gt;// The stack_traces map holds an array of memory addresses,&lt;/span&gt;
&lt;span class="c1"&gt;// e.g., stack_traces[1253] = [0xdeadbeef, 0x123abcde]&lt;/span&gt;
&lt;span class="c1"&gt;// where 1253 is a stack ID.&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;__uint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BPF_MAP_TYPE_STACK_TRACE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;__uint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max_entries&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MAX_STACK_ADDRESSES&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;__type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;u32&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;__type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stack_trace_type&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;stack_traces&lt;/span&gt; &lt;span class="n"&gt;SEC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;.maps&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;stack_count_key_t&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;u32&lt;/span&gt; &lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;int32&lt;/span&gt; &lt;span class="n"&gt;user_stack_id&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;int32&lt;/span&gt; &lt;span class="n"&gt;kernel_stack_id&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c1"&gt;// The counts map keeps track of how many times a stack trace has been seen,&lt;/span&gt;
&lt;span class="c1"&gt;// e.g., counts[{10342, 1253, 0234}] = 45 times.&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;__uint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BPF_MAP_TYPE_HASH&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;__uint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max_entries&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10240&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;__type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;stack_count_key_t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;__type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;u64&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;counts&lt;/span&gt; &lt;span class="n"&gt;SEC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;.maps&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The BPF program records stack traces in special &lt;code&gt;stack_traces&lt;/code&gt; BPF map
which is indexed by stack IDs.
The map value is an array of memory addresses that represent the code executed.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;stack ID&lt;/th&gt;
&lt;th&gt;memory addresses&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1253&lt;/td&gt;
&lt;td&gt;[ 0xdeadbeef; 0x123abcde; ... ]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0234&lt;/td&gt;
&lt;td&gt;[ 0x597be95a; 0xae5ee03; ... ]&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The &lt;code&gt;counts&lt;/code&gt; BPF map keeps track of how many times a stack trace has been seen:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;its key is a triple of PID, user-space stack ID, and kernel-space stack ID, see &lt;code&gt;struct stack_count_key_t { ... }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;its value is the amount of times that stack trace has been observed&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;stack_count_key_t&lt;/th&gt;
&lt;th&gt;seen&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;{ 10342; 1253; 0234 }&lt;/td&gt;
&lt;td&gt;45&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The maps are populated using
&lt;a href="https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/bpf.h#L2080"&gt;bpf_get_stackid()&lt;/a&gt;
and &lt;code&gt;bpf_map_lookup_or_try_init()&lt;/code&gt; functions.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// Create a key for &amp;quot;counts&amp;quot; map.&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;stack_count_key_t&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{.&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tgid&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="c1"&gt;// Read user-space stack ID and insert memory addresses into stack_traces map.&lt;/span&gt;
&lt;span class="c1"&gt;// The positive or null stack id is returned on success,&lt;/span&gt;
&lt;span class="c1"&gt;// or a negative error in case of failure.&lt;/span&gt;
&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;user_stack_id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bpf_get_stackid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;stack_traces&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BPF_F_USER_STACK&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;// Read kernel-space stack ID and insert memory addresses into stack_traces map.&lt;/span&gt;
&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;kernel_stack_id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bpf_get_stackid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;stack_traces&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;u64&lt;/span&gt; &lt;span class="n"&gt;zero&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;u64&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;seen&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;seen&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bpf_map_lookup_or_try_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;counts&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;zero&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;seen&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;// Atomically increments the seen counter.&lt;/span&gt;
&lt;span class="n"&gt;__sync_fetch_and_add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;seen&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;On Go side the BPF maps are read every 10 seconds,
get processed, and then purged to reset for the next iteration.&lt;/p&gt;
&lt;h3&gt;DIY profiler&lt;/h3&gt;
&lt;p&gt;Parca Agent relies on &lt;a href="https://github.com/aquasecurity/libbpfgo"&gt;cgo bindings for libbpf&lt;/a&gt; from Aqua Security.
I wanted to make something similar using
&lt;a href="https://github.com/cilium/ebpf"&gt;github.com/cilium/ebpf&lt;/a&gt; which doesn't need cgo.&lt;/p&gt;
&lt;p&gt;In order to prepare the environment I ran Ubuntu 21.10 in a virtual machine and installed Clang with Go.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;ï¹ª cat &amp;gt; Vagrantfile &amp;lt;&amp;lt;CFG&lt;/span&gt;
&lt;span class="go"&gt;Vagrant.configure(&amp;quot;2&amp;quot;) do |config|&lt;/span&gt;
&lt;span class="go"&gt;    config.vm.box = &amp;quot;ubuntu/impish64&amp;quot;&lt;/span&gt;
&lt;span class="go"&gt;end&lt;/span&gt;
&lt;span class="go"&gt;CFG&lt;/span&gt;
&lt;span class="go"&gt;ï¹ª vagrant up&lt;/span&gt;
&lt;span class="go"&gt;ï¹ª vagrant ssh&lt;/span&gt;
&lt;span class="go"&gt;ï¹© sudo apt-get update&lt;/span&gt;
&lt;span class="go"&gt;ï¹© sudo apt-get install clang&lt;/span&gt;
&lt;span class="go"&gt;ï¹© sudo snap install go --classic&lt;/span&gt;
&lt;span class="go"&gt;ï¹© uname -nr&lt;/span&gt;
&lt;span class="go"&gt;ubuntu-impish 5.13.0-39-generic&lt;/span&gt;
&lt;span class="go"&gt;ï¹© clang -v&lt;/span&gt;
&lt;span class="go"&gt;Ubuntu clang version 13.0.0-2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Then I copied
&lt;a href="https://github.com/parca-dev/parca-agent/blob/31253527651ebebb74c6200eb68fe9251479ed6b/parca-agent.bpf.c"&gt;parca-agent.bpf.c&lt;/a&gt;
from parca-agent repository and tried to generate Go files using bpf2go tool.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;ï¹© cd /vagrant/&lt;/span&gt;
&lt;span class="go"&gt;ï¹© mkdir -p cmd/profiler/bpf/&lt;/span&gt;
&lt;span class="go"&gt;ï¹© curl -o cmd/profiler/bpf/parca-agent.bpf.c https://raw.githubusercontent.com/parca-dev/parca-agent/31253527651ebebb74c6200eb68fe9251479ed6b/parca-agent.bpf.c&lt;/span&gt;
&lt;span class="go"&gt;ï¹© cat &amp;gt; cmd/profiler/main.go &amp;lt;&amp;lt;&amp;lt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="go"&gt;package main&lt;/span&gt;

&lt;span class="go"&gt;//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -cflags $BPF_CFLAGS -cc clang-13 ParcaAgent ./bpf/parca-agent.bpf.c -- -I../../headers&lt;/span&gt;

&lt;span class="go"&gt;func main() {}&lt;/span&gt;
&lt;span class="go"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="go"&gt;ï¹© go mod init diy-parca-agent&lt;/span&gt;
&lt;span class="go"&gt;ï¹© go get github.com/cilium/ebpf/cmd/bpf2go&lt;/span&gt;
&lt;span class="go"&gt;ï¹© go generate ./cmd/profiler/&lt;/span&gt;
&lt;span class="go"&gt;/vagrant/cmd/profiler/bpf/parca-agent.bpf.c:11:10: fatal error: &amp;#39;vmlinux.h&amp;#39; file not found&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;vmlinux.h&lt;/code&gt; can be generated from the installed kernel using bpftool tool.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;ï¹© mkdir headers&lt;/span&gt;
&lt;span class="go"&gt;ï¹© sudo apt-get install linux-tools-$(uname -r) linux-tools-common&lt;/span&gt;
&lt;span class="go"&gt;ï¹© bpftool btf dump file /sys/kernel/btf/vmlinux format c &amp;gt; ./headers/vmlinux.h&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The remaining missing headers I copied from ubuntu-kernel, libbpf, and cilium repositories.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;ï¹© curl -o ./headers/bpf_core_read.h https://git.launchpad.net/~ubuntu-kernel/ubuntu/+source/linux/+git/impish/plain/tools/lib/bpf/bpf_core_read.h&lt;/span&gt;
&lt;span class="go"&gt;ï¹© curl -o ./headers/bpf_endian.h https://raw.githubusercontent.com/cilium/ebpf/master/examples/headers/bpf_endian.h&lt;/span&gt;
&lt;span class="go"&gt;ï¹© curl -o ./headers/bpf_helpers.h https://git.launchpad.net/~ubuntu-kernel/ubuntu/+source/linux/+git/impish/plain/tools/lib/bpf/bpf_helpers.h&lt;/span&gt;
&lt;span class="go"&gt;ï¹© curl -o ./headers/bpf_tracing.h https://git.launchpad.net/~ubuntu-kernel/ubuntu/+source/linux/+git/impish/plain/tools/lib/bpf/bpf_tracing.h&lt;/span&gt;
&lt;span class="go"&gt;ï¹© curl -o ./headers/bpf_helper_defs.h https://raw.githubusercontent.com/libbpf/libbpf/master/src/bpf_helper_defs.h&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Finally, all the dependencies were resolved and Go code was generated.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;ï¹© go generate ./cmd/profiler/&lt;/span&gt;
&lt;span class="go"&gt;Compiled /vagrant/cmd/profiler/parcaagent_bpfel.o&lt;/span&gt;
&lt;span class="go"&gt;Stripped /vagrant/cmd/profiler/parcaagent_bpfel.o&lt;/span&gt;
&lt;span class="go"&gt;Wrote /vagrant/cmd/profiler/parcaagent_bpfel.go&lt;/span&gt;
&lt;span class="go"&gt;Compiled /vagrant/cmd/profiler/parcaagent_bpfeb.o&lt;/span&gt;
&lt;span class="go"&gt;Stripped /vagrant/cmd/profiler/parcaagent_bpfeb.o&lt;/span&gt;
&lt;span class="go"&gt;Wrote /vagrant/cmd/profiler/parcaagent_bpfeb.go&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Next step was to see whether &lt;code&gt;DoSample&lt;/code&gt; BPF program is loaded into the kernel from an ELF.
&lt;code&gt;ParcaAgentObjects{}&lt;/code&gt; contains all objects (BPF program and BPF maps) after they have been loaded into the kernel.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nx"&gt;objs&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;ParcaAgentObjects&lt;/span&gt;&lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;LoadParcaAgentObjects&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;objs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;failed to load BPF program and maps: %v&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;defer&lt;/span&gt; &lt;span class="nx"&gt;objs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;It worked, no errors were printed.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;ï¹© sudo go run ./cmd/profiler/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;A call to perf_event_open() creates a file descriptor
that allows measuring performance information.
Each file descriptor corresponds to one event that is measured.
Events can be enabled and disabled via ioctl(2).
https://man7.org/linux/man-pages/man2/perf_event_open.2.html&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;It's time to attach &lt;code&gt;DoSample&lt;/code&gt; BPF program to perf event using
&lt;code&gt;unix.PerfEventOpen()&lt;/code&gt; and &lt;code&gt;unix.IoctlSetInt()&lt;/code&gt; functions.
Note, Parca Agent doesn't directly use &lt;code&gt;unix.IoctlSetInt()&lt;/code&gt; and relies on
&lt;a href="https://pkg.go.dev/github.com/aquasecurity/libbpfgo#BPFProg.AttachPerfEvent"&gt;AttachPerfEvent()&lt;/a&gt;
function from &lt;a href="http://github.com/aquasecurity/libbpfgo"&gt;github.com/aquasecurity/libbpfgo&lt;/a&gt;.
I found cilium related explanation &lt;a href="https://github.com/cilium/ebpf/discussions/548"&gt;#548&lt;/a&gt;
how to achieve the same thing:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Load the BPF program into the kernel: &lt;code&gt;LoadParcaAgentObjects(&amp;amp;objs, nil)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Open the perf event: &lt;code&gt;fd, _ := unix.PerfEventOpen(...)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Set the BPF program on the perf event:
  &lt;code&gt;unix.IoctlSetInt(fd, unix.PERF_EVENT_IOC_SET_BPF, objs.DoSample.FD())&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Enable the perf event:
   &lt;code&gt;unix.IoctlSetInt(fd, unix.PERF_EVENT_IOC_ENABLE, 0)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Those steps worked as well.
I was hopeful to see whether stack traces were collected,
so I periodically printed the content of &lt;code&gt;Counts&lt;/code&gt; BPF map.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;stackCountKey&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;PID&lt;/span&gt;           &lt;span class="kt"&gt;uint32&lt;/span&gt;
    &lt;span class="nx"&gt;UserStackID&lt;/span&gt;   &lt;span class="kt"&gt;int32&lt;/span&gt;
    &lt;span class="nx"&gt;KernelStackID&lt;/span&gt; &lt;span class="kt"&gt;int32&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="nx"&gt;key&lt;/span&gt;   &lt;span class="nx"&gt;stackCountKey&lt;/span&gt;
    &lt;span class="nx"&gt;value&lt;/span&gt; &lt;span class="kt"&gt;uint64&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nx"&gt;it&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;objs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ParcaAgentMaps&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Counts&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Iterate&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;it&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%+v seen %d times\n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;it&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Err&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;failed to read from Counts map: %v&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The easiest way to reliably get stack traces was to run &lt;code&gt;top&lt;/code&gt; in another terminal.
I made the profiler focus on its PID 15958 and it worked ðŸŽ‰.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;ï¹© top&lt;/span&gt;
&lt;span class="go"&gt;ï¹© sudo go run ./cmd/profiler/ -pid 15958&lt;/span&gt;
&lt;span class="go"&gt;Waiting for stack traces...&lt;/span&gt;
&lt;span class="go"&gt;{PID:15958 UserStackID:132 KernelStackID:114} seen 1 times&lt;/span&gt;
&lt;span class="go"&gt;{PID:15958 UserStackID:709 KernelStackID:-14} seen 1 times # -14 indicates bpf_get_stackid() error.&lt;/span&gt;
&lt;span class="go"&gt;{PID:15958 UserStackID:366 KernelStackID:30} seen 2 times&lt;/span&gt;
&lt;span class="go"&gt;{PID:15958 UserStackID:674 KernelStackID:943} seen 1 times&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The end of my post is an disappointing anticlimax because
I haven't looked yet at how to show the actual stack traces.
I will update &lt;a href="https://github.com/marselester/diy-parca-agent"&gt;the repository&lt;/a&gt; when I have time.&lt;/p&gt;</content><category term="bpf"></category><category term="golang"></category><category term="monitoring"></category></entry><entry><title>BPF Go program in Kubernetes</title><link href="https://marselester.com/bpf-go-program-in-kubernetes.html" rel="alternate"></link><published>2021-11-17T00:00:00+07:00</published><updated>2021-11-17T00:00:00+07:00</updated><author><name>Marsel Mavletkulov</name></author><id>tag:marselester.com,2021-11-17:/bpf-go-program-in-kubernetes.html</id><summary type="html">&lt;p&gt;BPF opens a lot of possibilities of making observability tools running in Kubernetes.
One can start with &lt;a href="https://github.com/iovisor/bcc/tree/master/libbpf-tools"&gt;BCC libbpf-tools&lt;/a&gt; written in C,
e.g., launch tcpconnlat program and process its stdout with another program to
detect cases when it took too long to establish a TCP connection.
For example, &lt;code&gt;curl â€¦&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;BPF opens a lot of possibilities of making observability tools running in Kubernetes.
One can start with &lt;a href="https://github.com/iovisor/bcc/tree/master/libbpf-tools"&gt;BCC libbpf-tools&lt;/a&gt; written in C,
e.g., launch tcpconnlat program and process its stdout with another program to
detect cases when it took too long to establish a TCP connection.
For example, &lt;code&gt;curl http://example.com&lt;/code&gt; took 47.8 milliseconds to establish a connection
where source address is &lt;code&gt;10.0.2.15&lt;/code&gt; and destination address is &lt;code&gt;93.184.216.34&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;PID    COMM         IP SADDR            DADDR            DPORT LAT(ms)&lt;/span&gt;
&lt;span class="go"&gt;21500  curl         4  10.0.2.15        93.184.216.34    80    47.80&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Another option is to use Go version of
&lt;a href="https://github.com/marselester/libbpf-tools/blob/master/cmd/tcpconnlat/main.go"&gt;tcpconnlat&lt;/a&gt;
and modify it as you wish, e.g., write the events into Kafka for further analysis.&lt;/p&gt;
&lt;p&gt;I have already published a Docker image
&lt;a href="https://github.com/marselester/libbpf-tools/blob/master/Dockerfile"&gt;marselester/go-libbpf-tools&lt;/a&gt;
containing tcpconnlat and tried to run it on Mac, that didn't go well though.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;ï¹ª docker run --rm -it --privileged marselester/go-libbpf-tools:latest bash&lt;/span&gt;
&lt;span class="go"&gt;root@552a159ce901:/opt/libbpf-toolsï¼ƒ ./tcpconnlat&lt;/span&gt;
&lt;span class="go"&gt;failed to load BPF programs and maps: field TcpRcvStateProcess: program tcp_rcv_state_process: CO-RE relocations: no BTF for kernel version 5.10.47-linuxkit: not supported&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Minikube with Virtualbox driver didn't help either because it uses an old kernel,
hopefully it will be upgraded soon &lt;a href="https://github.com/kubernetes/minikube/issues/10501"&gt;#10501&lt;/a&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;ï¹ª minikube start --driver=virtualbox&lt;/span&gt;
&lt;span class="go"&gt;ï¹ª minikube ssh&lt;/span&gt;
&lt;span class="go"&gt;ï¹© uname -nr&lt;/span&gt;
&lt;span class="go"&gt;Linux minikube 4.19.202&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Luckily there is another option called &lt;a href="https://kubespray.io"&gt;Kubespray&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Kubespray&lt;/h2&gt;
&lt;p&gt;Kubespray sets up a Kubernetes cluster of 3 nodes using Vagrant and Ansible.
Clone the repository and install Python dependencies for provisioning tasks.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;ï¹ª git clone https://github.com/kubernetes-sigs/kubespray&lt;/span&gt;
&lt;span class="go"&gt;ï¹ª cd ./kubespray/&lt;/span&gt;
&lt;span class="go"&gt;ï¹ª virtualenv venv&lt;/span&gt;
&lt;span class="go"&gt;ï¹ª source ./venv/bin/activate&lt;/span&gt;
&lt;span class="gp gp-VirtualEnv"&gt;(venv)&lt;/span&gt; &lt;span class="go"&gt;ï¹ª pip install -r requirements.txt&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;From looking at &lt;a href="https://github.com/kubernetes-sigs/kubespray/blob/master/Vagrantfile"&gt;the Vagrantfile&lt;/a&gt;
we see that Kubespray supports Fedora Linux 34, so BTF and CO-RE technologies should be there.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;ï¹ª mkdir vagrant&lt;/span&gt;
&lt;span class="go"&gt;ï¹ª echo &amp;#39;$os = &amp;quot;fedora34&amp;quot;&amp;#39; &amp;gt; ./vagrant/config.rb&lt;/span&gt;
&lt;span class="go"&gt;ï¹ª vagrant up&lt;/span&gt;
&lt;span class="go"&gt;ï¹ª export KUBECONFIG=$(pwd)/.vagrant/provisioners/ansible/inventory/artifacts/admin.conf&lt;/span&gt;
&lt;span class="go"&gt;ï¹ª kubectl get nodes&lt;/span&gt;
&lt;span class="go"&gt;NAME    STATUS   ROLES                  AGE     VERSION&lt;/span&gt;
&lt;span class="go"&gt;k8s-1   Ready    control-plane,master   8m20s   v1.22.3&lt;/span&gt;
&lt;span class="go"&gt;k8s-2   Ready    control-plane,master   7m56s   v1.22.3&lt;/span&gt;
&lt;span class="go"&gt;k8s-3   Ready    &amp;lt;none&amp;gt;                 6m58s   v1.22.3&lt;/span&gt;
&lt;span class="go"&gt;ï¹ª vagrant ssh k8s-1&lt;/span&gt;
&lt;span class="go"&gt;ï¹© uname -nr&lt;/span&gt;
&lt;span class="go"&gt;k8s-1 5.11.12-300.fc34.x86_64&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;See &lt;a href="https://github.com/kubernetes-sigs/kubespray/blob/master/docs/vagrant.md"&gt;vagrant.md&lt;/a&gt;
if the cluster wasn't provisioned.&lt;/p&gt;
&lt;h2&gt;DaemonSet&lt;/h2&gt;
&lt;p&gt;An observability tool should run on each node,
and a &lt;a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/"&gt;DaemonSet&lt;/a&gt;
ensures that all nodes run a copy of a pod.
Let's try to launch tcpconnlat on all 3 nodes.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;ï¹ª kubectl apply -f - &amp;lt;&amp;lt;&amp;lt;&amp;#39;&lt;/span&gt;
&lt;span class="go"&gt;apiVersion: apps/v1&lt;/span&gt;
&lt;span class="go"&gt;kind: DaemonSet&lt;/span&gt;
&lt;span class="go"&gt;metadata:&lt;/span&gt;
&lt;span class="go"&gt;  name: tcpconnlat-daemon&lt;/span&gt;
&lt;span class="go"&gt;spec:&lt;/span&gt;
&lt;span class="go"&gt;  selector:&lt;/span&gt;
&lt;span class="go"&gt;    matchLabels:&lt;/span&gt;
&lt;span class="go"&gt;      app: tcpconnlat&lt;/span&gt;
&lt;span class="go"&gt;  template:&lt;/span&gt;
&lt;span class="go"&gt;    metadata:&lt;/span&gt;
&lt;span class="go"&gt;      labels:&lt;/span&gt;
&lt;span class="go"&gt;        app: tcpconnlat&lt;/span&gt;
&lt;span class="go"&gt;    spec:&lt;/span&gt;
&lt;span class="go"&gt;      containers:&lt;/span&gt;
&lt;span class="go"&gt;        - name: libbpf-tools&lt;/span&gt;
&lt;span class="go"&gt;          image: marselester/go-libbpf-tools:latest&lt;/span&gt;
&lt;span class="go"&gt;          command:&lt;/span&gt;
&lt;span class="go"&gt;            - /opt/libbpf-tools/tcpconnlat&lt;/span&gt;
&lt;span class="go"&gt;&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Unfortunately pods have crashed because the containers didn't have privileged mode.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;ï¹ª kubectl get pods&lt;/span&gt;
&lt;span class="go"&gt;NAME                      READY   STATUS             RESTARTS        AGE&lt;/span&gt;
&lt;span class="go"&gt;tcpconnlat-daemon-646h2   0/1     CrashLoopBackOff   5 (2m9s ago)    5m13s&lt;/span&gt;
&lt;span class="go"&gt;tcpconnlat-daemon-hwnzt   0/1     CrashLoopBackOff   5 (118s ago)    5m13s&lt;/span&gt;
&lt;span class="go"&gt;tcpconnlat-daemon-tmn6r   0/1     CrashLoopBackOff   5 (2m14s ago)   5m13s&lt;/span&gt;
&lt;span class="go"&gt;ï¹ª kubectl logs -f tcpconnlat-daemon-646h2&lt;/span&gt;
&lt;span class="go"&gt;failed to set temporary RLIMIT_MEMLOCK: operation not permitted&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Let's enable it.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;By default a container is not allowed to access any devices on the host,
but a "privileged" container is given access to all devices on the host.
This allows the container nearly all the same access as processes running on the host.&lt;/p&gt;
&lt;p&gt;https://kubernetes.io/docs/concepts/policy/pod-security-policy/#privileged&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;ï¹ª kubectl apply -f - &amp;lt;&amp;lt;&amp;lt;&amp;#39;&lt;/span&gt;
&lt;span class="go"&gt;apiVersion: apps/v1&lt;/span&gt;
&lt;span class="go"&gt;kind: DaemonSet&lt;/span&gt;
&lt;span class="go"&gt;metadata:&lt;/span&gt;
&lt;span class="go"&gt;  name: tcpconnlat-daemon&lt;/span&gt;
&lt;span class="go"&gt;spec:&lt;/span&gt;
&lt;span class="go"&gt;  selector:&lt;/span&gt;
&lt;span class="go"&gt;    matchLabels:&lt;/span&gt;
&lt;span class="go"&gt;      app: tcpconnlat&lt;/span&gt;
&lt;span class="go"&gt;  template:&lt;/span&gt;
&lt;span class="go"&gt;    metadata:&lt;/span&gt;
&lt;span class="go"&gt;      labels:&lt;/span&gt;
&lt;span class="go"&gt;        app: tcpconnlat&lt;/span&gt;
&lt;span class="go"&gt;    spec:&lt;/span&gt;
&lt;span class="go"&gt;      containers:&lt;/span&gt;
&lt;span class="go"&gt;        - name: libbpf-tools&lt;/span&gt;
&lt;span class="go"&gt;          image: marselester/go-libbpf-tools:latest&lt;/span&gt;
&lt;span class="go"&gt;          command:&lt;/span&gt;
&lt;span class="go"&gt;            - /opt/libbpf-tools/tcpconnlat&lt;/span&gt;
&lt;span class="go"&gt;          securityContext:&lt;/span&gt;
&lt;span class="go"&gt;            privileged: true&lt;/span&gt;
&lt;span class="go"&gt;&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;It works! ðŸ‘‡&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;ï¹ª kubectl get pods&lt;/span&gt;
&lt;span class="go"&gt;NAME                      READY   STATUS    RESTARTS   AGE&lt;/span&gt;
&lt;span class="go"&gt;tcpconnlat-daemon-9sgc5   1/1     Running   0          18s&lt;/span&gt;
&lt;span class="go"&gt;tcpconnlat-daemon-lrvh5   1/1     Running   0          18s&lt;/span&gt;
&lt;span class="go"&gt;tcpconnlat-daemon-th9k4   1/1     Running   0          18s&lt;/span&gt;
&lt;span class="go"&gt;ï¹ª kubectl logs -f tcpconnlat-daemon-9sgc5&lt;/span&gt;
&lt;span class="go"&gt;PID    COMM         IP SADDR            DADDR            DPORT LAT(ms)&lt;/span&gt;
&lt;span class="go"&gt;5955   coredns      4  127.0.0.1        127.0.0.1        8080  0.02&lt;/span&gt;
&lt;span class="go"&gt;703    kubelet      4  172.18.8.101     172.18.8.101     6443  0.04&lt;/span&gt;
&lt;span class="go"&gt;703    kubelet      4  10.233.64.1      10.233.64.4      8181  0.07&lt;/span&gt;
&lt;span class="go"&gt;703    kubelet      4  169.254.25.10    169.254.25.10    9254  0.03&lt;/span&gt;
&lt;span class="go"&gt;703    kubelet      4  10.233.64.1      10.233.64.5      8080  0.03&lt;/span&gt;
&lt;span class="go"&gt;5537   node-cache   4  169.254.25.10    169.254.25.10    9254  0.06&lt;/span&gt;
&lt;span class="go"&gt;4204   etcd         4  172.18.8.101     172.18.8.103     2380  0.22&lt;/span&gt;
&lt;span class="go"&gt;4204   etcd         4  172.18.8.101     172.18.8.102     2380  0.21&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;I also tried to run execsnoop and tcpconnect, but alas they crashed with the corresponding errors.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;failed to attach the BPF program to sys_enter_execve tracepoint: trace event syscalls/sys_enter_execve: file does not exist&lt;/span&gt;

&lt;span class="go"&gt;failed to load BPF programs and maps: field TcpV4ConnectRet: program tcp_v4_connect_ret: load program: permission denied: trace type programs with run-time allocated hash maps are unsafe. Switch to preallocated hash maps.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="bpf"></category><category term="golang"></category><category term="kubernetes"></category></entry><entry><title>BPF: Go frontend for tcpconnect</title><link href="https://marselester.com/bpf-go-frontend-for-tcpconnect.html" rel="alternate"></link><published>2021-11-01T00:00:00+07:00</published><updated>2021-11-01T00:00:00+07:00</updated><author><name>Marsel Mavletkulov</name></author><id>tag:marselester.com,2021-11-01:/bpf-go-frontend-for-tcpconnect.html</id><summary type="html">&lt;p&gt;&lt;a href="https://marselester.com/bpf-go-frontend-for-execsnoop.html"&gt;In the previos BPF post&lt;/a&gt;
I shared my experiment of writing Go frontend for execsnoop.
Here I would like to focus on tcpconnect, a BCC tool to trace new TCP active connections.
It is useful for determining who is connecting to whom.
This works by tracing the &lt;code&gt;tcp_v4_connect()&lt;/code&gt; and &lt;code&gt;tcp_v6_connect â€¦&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://marselester.com/bpf-go-frontend-for-execsnoop.html"&gt;In the previos BPF post&lt;/a&gt;
I shared my experiment of writing Go frontend for execsnoop.
Here I would like to focus on tcpconnect, a BCC tool to trace new TCP active connections.
It is useful for determining who is connecting to whom.
This works by tracing the &lt;code&gt;tcp_v4_connect()&lt;/code&gt; and &lt;code&gt;tcp_v6_connect()&lt;/code&gt; kernel functions.&lt;/p&gt;
&lt;p&gt;As before, I tried to make Go tcpconnect's output match the original program,
so I copied the ELF binary &lt;code&gt;tcpconnect&lt;/code&gt; from a Docker container to the virtual machine
(Ubuntu 21.04 from the previos post).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;ï¹ª docker run --name libbpf marselester/libbpf-tools:latest&lt;/span&gt;
&lt;span class="go"&gt;ï¹ª docker cp libbpf:/opt/tcpconnect .&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The tcpconnect captured &lt;code&gt;curl example.com&lt;/code&gt; running in another terminal:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PID &lt;em&gt;93336&lt;/em&gt; is the process ID that opened the connection&lt;/li&gt;
&lt;li&gt;COMM &lt;em&gt;curl&lt;/em&gt; is the process name that opened the connection, e.g., via a &lt;code&gt;connect()&lt;/code&gt; syscall&lt;/li&gt;
&lt;li&gt;IP &lt;em&gt;4&lt;/em&gt; stands for IP v4 address protocol&lt;/li&gt;
&lt;li&gt;SADDR &lt;em&gt;10.0.2.15&lt;/em&gt; is the source address&lt;/li&gt;
&lt;li&gt;DADDR &lt;em&gt;93.184.216.34&lt;/em&gt; is the destination address&lt;/li&gt;
&lt;li&gt;DPORT &lt;em&gt;80&lt;/em&gt; is the destination port&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;ï¹© sudo /vagrant/tcpconnect&lt;/span&gt;
&lt;span class="go"&gt;PID    COMM         IP SADDR            DADDR            DPORT&lt;/span&gt;
&lt;span class="go"&gt;93336  curl         4  10.0.2.15        93.184.216.34    80&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;Embedding BPF in Go&lt;/h2&gt;
&lt;p&gt;The tcpconnect BPF program comprises of
&lt;a href="https://github.com/iovisor/bcc/blob/master/libbpf-tools/tcpconnect.bpf.c"&gt;tcpconnect.bpf.c&lt;/a&gt;,
&lt;a href="https://github.com/iovisor/bcc/blob/master/libbpf-tools/tcpconnect.h"&gt;tcpconnect.h&lt;/a&gt;,
and &lt;a href="https://github.com/iovisor/bcc/blob/master/libbpf-tools/maps.bpf.h"&gt;maps.bpf.h&lt;/a&gt; files.
Let's copy them from BCC toolkit and generate Go files.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;ï¹© cd /vagrant/&lt;/span&gt;
&lt;span class="go"&gt;ï¹© mkdir -p cmd/tcpconnect/bpf/&lt;/span&gt;
&lt;span class="go"&gt;ï¹© curl -o cmd/tcpconnect/bpf/tcpconnect.bpf.c https://raw.githubusercontent.com/iovisor/bcc/master/libbpf-tools/tcpconnect.bpf.c&lt;/span&gt;
&lt;span class="go"&gt;ï¹© curl -o cmd/tcpconnect/bpf/tcpconnect.h https://raw.githubusercontent.com/iovisor/bcc/master/libbpf-tools/tcpconnect.h&lt;/span&gt;
&lt;span class="go"&gt;ï¹© curl -o cmd/tcpconnect/bpf/maps.bpf.h https://raw.githubusercontent.com/iovisor/bcc/master/libbpf-tools/maps.bpf.h&lt;/span&gt;
&lt;span class="go"&gt;ï¹© cat &amp;gt; cmd/tcpconnect/main.go &amp;lt;&amp;lt;&amp;lt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="go"&gt;package main&lt;/span&gt;

&lt;span class="go"&gt;//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -cflags $BPF_CFLAGS -cc clang-12 TCPConnect ./bpf/tcpconnect.bpf.c -- -I../../headers&lt;/span&gt;

&lt;span class="go"&gt;func main() {}&lt;/span&gt;
&lt;span class="go"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="go"&gt;ï¹© go generate ./cmd/tcpconnect/&lt;/span&gt;
&lt;span class="go"&gt;/vagrant/cmd/tcpconnect/bpf/tcpconnect.bpf.c:9:10: fatal error: &amp;#39;bpf/bpf_tracing.h&amp;#39; file not found&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Since &lt;code&gt;bpf_tracing.h&lt;/code&gt; file is missing, let's get it from ubuntu-kernel repository
and run &lt;code&gt;go generate&lt;/code&gt; again,
but this time with &lt;code&gt;BPF_CFLAGS='-D__TARGET_ARCH_x86'&lt;/code&gt; env var (a compiler flag) because
&lt;a href="https://elixir.bootlin.com/linux/latest/source/tools/lib/bpf/bpf_tracing.h#L5"&gt;bpf_tracing.h&lt;/a&gt; expects it.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;ï¹© curl -o ./headers/bpf/bpf_tracing.h https://git.launchpad.net/~ubuntu-kernel/ubuntu/+source/linux/+git/hirsute/plain/tools/lib/bpf/bpf_tracing.h&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;It worked out ðŸ˜¬.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;ï¹© BPF_CFLAGS=&amp;#39;-D__TARGET_ARCH_x86&amp;#39; go generate ./cmd/tcpconnect/&lt;/span&gt;
&lt;span class="go"&gt;Compiled /vagrant/cmd/tcpconnect/tcpconnect_bpfel.o&lt;/span&gt;
&lt;span class="go"&gt;Wrote /vagrant/cmd/tcpconnect/tcpconnect_bpfel.go&lt;/span&gt;
&lt;span class="go"&gt;Compiled /vagrant/cmd/tcpconnect/tcpconnect_bpfeb.o&lt;/span&gt;
&lt;span class="go"&gt;Wrote /vagrant/cmd/tcpconnect/tcpconnect_bpfeb.go&lt;/span&gt;
&lt;span class="go"&gt;ï¹© sudo go run ./cmd/tcpconnect/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;BPF programs loading looks very similar to Go execsnoop version,
though instead of calling &lt;code&gt;LoadTCPConnectObjects()&lt;/code&gt; the &lt;code&gt;LoadTCPConnect()&lt;/code&gt; is called to
parse an ELF file into &lt;code&gt;spec&lt;/code&gt; struct (a collection of BPF maps and programs) and
replace constants in the C program to filter connections by PID or UID.
Here is how they are defined in &lt;code&gt;tcpconnect.bpf.c&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;volatile&lt;/span&gt; &lt;span class="kt"&gt;uid_t&lt;/span&gt; &lt;span class="n"&gt;filter_uid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;volatile&lt;/span&gt; &lt;span class="kt"&gt;pid_t&lt;/span&gt; &lt;span class="n"&gt;filter_pid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;After the constants are rewritten, the BPF programs get loaded into the kernel with &lt;code&gt;spec.LoadAndAssign()&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;flag&amp;quot;&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;log&amp;quot;&lt;/span&gt;

    &lt;span class="s"&gt;&amp;quot;golang.org/x/sys/unix&amp;quot;&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -cflags $BPF_CFLAGS -cc clang-12 TCPConnect ./bpf/tcpconnect.bpf.c -- -I../../headers&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="nx"&gt;filterUID&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;uid&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;trace this UID only&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="nx"&gt;filterPID&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;pid&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;trace this PID only&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Parse&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="c1"&gt;// Increase the resource limit of the current process to provide sufficient space&lt;/span&gt;
    &lt;span class="c1"&gt;// for locking memory for the BPF maps.&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;unix&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Setrlimit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;unix&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;RLIMIT_MEMLOCK&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;unix&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Rlimit&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;Cur&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;unix&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;RLIM_INFINITY&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;Max&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;unix&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;RLIM_INFINITY&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;});&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;failed to set temporary RLIMIT_MEMLOCK: %v&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;// Replace constants in the BPF C program to filter connections by PID or UID.&lt;/span&gt;
    &lt;span class="nx"&gt;spec&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;LoadTCPConnect&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;failed to load collection spec: %v&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;bpfConst&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;make&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;map&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="kd"&gt;interface&lt;/span&gt;&lt;span class="p"&gt;{})&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;filterUID&lt;/span&gt; &lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;bpfConst&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;filter_uid&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;uint32&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;filterUID&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;filterPID&lt;/span&gt; &lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;bpfConst&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;filter_pid&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;int32&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;filterPID&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;spec&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;RewriteConstants&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;bpfConst&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;failed to rewrite BPF constants: %v&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;// Load the BPF program into the kernel from an ELF.&lt;/span&gt;
    &lt;span class="c1"&gt;// TCPConnectObjects contains all objects (BPF programs and maps) after they have been loaded into the kernel:&lt;/span&gt;
    &lt;span class="c1"&gt;// - TcpV4Connect, TcpV4ConnectRet, TcpV6Connect, TcpV6ConnectRet BPF programs,&lt;/span&gt;
    &lt;span class="c1"&gt;// - Events, Ipv4Count, Ipv6Count, Sockets BPF maps.&lt;/span&gt;
    &lt;span class="nx"&gt;objs&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;TCPConnectObjects&lt;/span&gt;&lt;span class="p"&gt;{}&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;spec&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;LoadAndAssign&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;objs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;failed to load BPF programs and maps: %v&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;defer&lt;/span&gt; &lt;span class="nx"&gt;objs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;Kprobes&lt;/h2&gt;
&lt;p&gt;A BPF program is executed on events such as kprobes.
Kprobes provide kernel dynamic instrumentation for any kernel function,
and they can instrument instructions within functions.
There is also an interface called kretprobes for instrumenting when functions return, and their return values.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;tcpconnect.bpf.c&lt;/code&gt; lists four BPF programs that trace events related to creating TCP sessions:
enter and exit of &lt;code&gt;tcp_v4_connect()&lt;/code&gt; and &lt;code&gt;tcp_v6_connect()&lt;/code&gt; kernel functions.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;SEC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;kprobe/tcp_v4_connect&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;BPF_KPROBE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tcp_v4_connect&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;sock&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;enter_tcp_connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;SEC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;kretprobe/tcp_v4_connect&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;BPF_KRETPROBE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tcp_v4_connect_ret&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ret&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;exit_tcp_connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ret&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;SEC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;kprobe/tcp_v6_connect&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;BPF_KPROBE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tcp_v6_connect&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;sock&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;enter_tcp_connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;SEC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;kretprobe/tcp_v6_connect&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;BPF_KRETPROBE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tcp_v6_connect_ret&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ret&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;exit_tcp_connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ret&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;On Go side I attached the BPF programs to kprobes/kretprobes.
The &lt;code&gt;link.Kprobe()&lt;/code&gt;, &lt;code&gt;link.Kretprobe&lt;/code&gt; functions return a link (it represents a program attached to a BPF hook)
which is later used to detach a BPF program.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nx"&gt;tcpv4kp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;link&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Kprobe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;tcp_v4_connect&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;objs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;TCPConnectPrograms&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;TcpV4Connect&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;failed to attach the BPF program to tcp_v4_connect kprobe: %s&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;defer&lt;/span&gt; &lt;span class="nx"&gt;tcpv4kp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="nx"&gt;tcpv4krp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;link&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Kretprobe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;tcp_v4_connect&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;objs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;TCPConnectPrograms&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;TcpV4ConnectRet&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;failed to attach the BPF program to tcp_v4_connect kretprobe: %s&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;defer&lt;/span&gt; &lt;span class="nx"&gt;tcpv4krp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="nx"&gt;tcpv6kp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;link&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Kprobe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;tcp_v6_connect&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;objs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;TCPConnectPrograms&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;TcpV6Connect&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;failed to attach the BPF program to tcp_v6_connect kprobe: %s&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;defer&lt;/span&gt; &lt;span class="nx"&gt;tcpv6kp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="nx"&gt;tcpv6krp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;link&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Kretprobe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;tcp_v6_connect&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;objs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;TCPConnectPrograms&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;TcpV6ConnectRet&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;failed to attach the BPF program to tcp_v6_connect kretprobe: %s&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;defer&lt;/span&gt; &lt;span class="nx"&gt;tcpv6krp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code&gt;bpf_perf_event_output()&lt;/code&gt; C function emits records to user space via a BPF map &lt;code&gt;events&lt;/code&gt;
that accesses perf per-CPU ring buffers.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;__uint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BPF_MAP_TYPE_PERF_EVENT_ARRAY&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;__uint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key_size&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u32&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;__uint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value_size&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u32&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;events&lt;/span&gt; &lt;span class="n"&gt;SEC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;.maps&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;
&lt;span class="n"&gt;bpf_perf_event_output&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;events&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BPF_F_CURRENT_CPU&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In user space the events are read using &lt;code&gt;github.com/cilium/ebpf/perf&lt;/code&gt; package.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// Open a perf event reader from user space on the PERF_EVENT_ARRAY map&lt;/span&gt;
&lt;span class="c1"&gt;// defined in the BPF C program.&lt;/span&gt;
&lt;span class="nx"&gt;rd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;perf&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;NewReader&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;objs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;TCPConnectMaps&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Events&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Getpagesize&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;failed to create perf event reader: %v&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;defer&lt;/span&gt; &lt;span class="nx"&gt;rd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;record&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;rd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Read&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;perf&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;IsClosed&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;failed to read from perf ring buffer: %v&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;received from perf ring buffer: %s&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;record&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;RawSample&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Running &lt;code&gt;curl&lt;/code&gt; shows that the TCP connect events are captured.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;ï¹© sudo go run ./cmd/tcpconnect/&lt;/span&gt;
&lt;span class="go"&gt;received from perf ring buffer:&lt;/span&gt;
&lt;span class="go"&gt;]??&amp;quot;curl???0x??P&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;Decoding events&lt;/h2&gt;
&lt;p&gt;Let's decode the events and print them as the original tcpconnect program does.
As mentioned before, the &lt;code&gt;event&lt;/code&gt; Go struct should match its C counterpart.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;union&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;__u32&lt;/span&gt; &lt;span class="n"&gt;saddr_v4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;__u8&lt;/span&gt; &lt;span class="n"&gt;saddr_v6&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="k"&gt;union&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;__u32&lt;/span&gt; &lt;span class="n"&gt;daddr_v4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;__u8&lt;/span&gt; &lt;span class="n"&gt;daddr_v6&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;__u64&lt;/span&gt; &lt;span class="n"&gt;ts_us&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;__u32&lt;/span&gt; &lt;span class="n"&gt;af&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// AF_INET or AF_INET6&lt;/span&gt;
    &lt;span class="n"&gt;__u32&lt;/span&gt; &lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;__u32&lt;/span&gt; &lt;span class="n"&gt;uid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;__u16&lt;/span&gt; &lt;span class="n"&gt;dport&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;I wasn't sure how to represent &lt;code&gt;union { ... }&lt;/code&gt; in Go, so allocating 16-byte slice worked well,
since the union is only as big as necessary to hold its largest member (IPv6 address).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// event represents a perf event sent to user space from the BPF program running in the kernel.&lt;/span&gt;
&lt;span class="c1"&gt;// Note, that it must match the C event struct, and both C and Go structs must be aligned the same way.&lt;/span&gt;
&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;event&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// SrcAddr is the source address.&lt;/span&gt;
    &lt;span class="nx"&gt;SrcAddr&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="kt"&gt;byte&lt;/span&gt;
    &lt;span class="c1"&gt;// DstAddr is the destination address.&lt;/span&gt;
    &lt;span class="nx"&gt;DstAddr&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="kt"&gt;byte&lt;/span&gt;
    &lt;span class="c1"&gt;// Comm is the process name that opened the connection.&lt;/span&gt;
    &lt;span class="nx"&gt;Comm&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="kt"&gt;byte&lt;/span&gt;
    &lt;span class="c1"&gt;// Timestamp is the timestamp in microseconds.&lt;/span&gt;
    &lt;span class="nx"&gt;Timestamp&lt;/span&gt; &lt;span class="kt"&gt;uint64&lt;/span&gt;
    &lt;span class="c1"&gt;// AddrFam is the address family, 2 is AF_INET (IPv4), 10 is AF_INET6 (IPv6).&lt;/span&gt;
    &lt;span class="nx"&gt;AddrFam&lt;/span&gt; &lt;span class="kt"&gt;uint32&lt;/span&gt;
    &lt;span class="c1"&gt;// PID is the process ID that opened the connection.&lt;/span&gt;
    &lt;span class="nx"&gt;PID&lt;/span&gt; &lt;span class="kt"&gt;uint32&lt;/span&gt;
    &lt;span class="c1"&gt;// UID is the process user ID.&lt;/span&gt;
    &lt;span class="nx"&gt;UID&lt;/span&gt; &lt;span class="kt"&gt;uint32&lt;/span&gt;
    &lt;span class="c1"&gt;// DstPort is the destination port (uint16 in C struct).&lt;/span&gt;
    &lt;span class="c1"&gt;// Note, network byte order is big-endian.&lt;/span&gt;
    &lt;span class="nx"&gt;DstPort&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="kt"&gt;byte&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The source and destination addresses were pretty-printed using &lt;code&gt;net.IP&lt;/code&gt; type
(either 4-byte (IPv4) or 16-byte (IPv6) slice) depending on the address family
(&lt;code&gt;2&lt;/code&gt; is IPv4, &lt;code&gt;10&lt;/code&gt; is IPv6).&lt;/p&gt;
&lt;p&gt;The destination port (unsigned 16-bit integer in C struct) was translated with
&lt;code&gt;binary.BigEndian.Uint16()&lt;/code&gt; function because &lt;code&gt;DstPort&lt;/code&gt; byte order is big-endian
(most significant bits first).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;printEvent&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;w&lt;/span&gt; &lt;span class="nx"&gt;io&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Writer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;e&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;event&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="nx"&gt;srcAddr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;dstAddr&lt;/span&gt; &lt;span class="nx"&gt;net&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;IP&lt;/span&gt;
        &lt;span class="nx"&gt;ipVer&lt;/span&gt;            &lt;span class="kt"&gt;byte&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="nx"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;AddrFam&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="nx"&gt;srcAddr&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;net&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;IP&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;SrcAddr&lt;/span&gt;&lt;span class="p"&gt;[:&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
        &lt;span class="nx"&gt;dstAddr&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;net&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;IP&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;DstAddr&lt;/span&gt;&lt;span class="p"&gt;[:&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
        &lt;span class="nx"&gt;ipVer&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="nx"&gt;srcAddr&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;net&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;IP&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;SrcAddr&lt;/span&gt;&lt;span class="p"&gt;[:])&lt;/span&gt;
        &lt;span class="nx"&gt;dstAddr&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;net&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;IP&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;DstAddr&lt;/span&gt;&lt;span class="p"&gt;[:])&lt;/span&gt;
        &lt;span class="nx"&gt;ipVer&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Fprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="nx"&gt;w&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;%-6d %-12s %-2d %-16s %-16s %d\n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;PID&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;bytes&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;TrimRight&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Comm&lt;/span&gt;&lt;span class="p"&gt;[:],&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;\x00&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="nx"&gt;ipVer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;srcAddr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;dstAddr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;binary&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;BigEndian&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Uint16&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;DstPort&lt;/span&gt;&lt;span class="p"&gt;[:]),&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Putting it all together we've got a Go frontend for tcpconnect with ability
to filter connections by PID and UID ðŸŽ‰.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;ï¹© sudo go run ./cmd/tcpconnect/&lt;/span&gt;
&lt;span class="go"&gt;PID    COMM         IP SADDR            DADDR            DPORT&lt;/span&gt;
&lt;span class="go"&gt;189217 curl         4  10.0.2.15        93.184.216.34    80&lt;/span&gt;
&lt;span class="go"&gt;ï¹© ./tcpconnect -h&lt;/span&gt;
&lt;span class="go"&gt;Usage of tcpconnect:&lt;/span&gt;
&lt;span class="go"&gt;  -pid int&lt;/span&gt;
&lt;span class="go"&gt;        trace this PID only&lt;/span&gt;
&lt;span class="go"&gt;  -uid int&lt;/span&gt;
&lt;span class="go"&gt;        trace this UID only (default -1)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;You can find all the source code at
&lt;a href="https://github.com/marselester/libbpf-tools"&gt;github.com/marselester/libbpf-tools&lt;/a&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%-6s %-12s %-2s %-16s %-16s %s\n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;PID&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;COMM&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;IP&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;SADDR&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;DADDR&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;DPORT&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;record&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;rd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Read&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;perf&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;IsClosed&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;failed to read from perf ring buffer: %v&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;record&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;LostSamples&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ring event perf buffer is full, dropped %d samples&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;record&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;LostSamples&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;continue&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;e&lt;/span&gt; &lt;span class="nx"&gt;event&lt;/span&gt;
    &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;binary&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="nx"&gt;bytes&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;NewBuffer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;record&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;RawSample&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="nx"&gt;binary&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;LittleEndian&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;e&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;failed to parse perf event: %#+v&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;continue&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="nx"&gt;printEvent&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Stdout&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="bpf"></category><category term="golang"></category></entry><entry><title>BPF: Go frontend for execsnoop</title><link href="https://marselester.com/bpf-go-frontend-for-execsnoop.html" rel="alternate"></link><published>2021-10-26T00:00:00+07:00</published><updated>2021-10-26T00:00:00+07:00</updated><author><name>Marsel Mavletkulov</name></author><id>tag:marselester.com,2021-10-26:/bpf-go-frontend-for-execsnoop.html</id><summary type="html">&lt;p&gt;After reading Brendan Gregg's books about BPF I was excited to try and implement something in Go.
At a first glance it turned out I would need to install LLVM, Clang, and kernel header dependencies to run a simple program.
Fortunately &lt;a href="https://www.brendangregg.com/blog/2020-11-04/bpf-co-re-btf-libbpf.html"&gt;BTF, CO-RE technologies&lt;/a&gt;
eliminate those dependencies though kernel &amp;gt;=5 â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;After reading Brendan Gregg's books about BPF I was excited to try and implement something in Go.
At a first glance it turned out I would need to install LLVM, Clang, and kernel header dependencies to run a simple program.
Fortunately &lt;a href="https://www.brendangregg.com/blog/2020-11-04/bpf-co-re-btf-libbpf.html"&gt;BTF, CO-RE technologies&lt;/a&gt;
eliminate those dependencies though kernel &amp;gt;=5.8 should be used.&lt;/p&gt;
&lt;p&gt;Since I don't know C, I resorted to &lt;a href="https://github.com/iovisor/bcc/tree/master/libbpf-tools"&gt;BCC libbpf-tools&lt;/a&gt;,
from which I picked a few BPF C programs (tcpconnect.bpf.c, execsnoop.bpf.c) to write Go frontends.
Below I will be focusing on execsnoop,
and you can find my experiments at &lt;a href="https://github.com/marselester/libbpf-tools"&gt;github.com/marselester/libbpf-tools&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Preparing the environment&lt;/h2&gt;
&lt;p&gt;First things first, I ran Ubuntu 21.04 in a virtual machine and installed Clang, Go.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;ï¹ª cat &amp;gt; Vagrantfile &amp;lt;&amp;lt;CFG&lt;/span&gt;
&lt;span class="go"&gt;Vagrant.configure(&amp;quot;2&amp;quot;) do |config|&lt;/span&gt;
&lt;span class="go"&gt;    config.vm.box = &amp;quot;ubuntu/hirsute64&amp;quot;&lt;/span&gt;
&lt;span class="go"&gt;end&lt;/span&gt;
&lt;span class="go"&gt;CFG&lt;/span&gt;
&lt;span class="go"&gt;ï¹ª vagrant up&lt;/span&gt;
&lt;span class="go"&gt;ï¹ª vagrant ssh&lt;/span&gt;
&lt;span class="go"&gt;ï¹© sudo apt-get update&lt;/span&gt;
&lt;span class="go"&gt;ï¹© sudo apt-get install clang&lt;/span&gt;
&lt;span class="go"&gt;ï¹© sudo snap install go --classic&lt;/span&gt;
&lt;span class="go"&gt;ï¹© uname -nr&lt;/span&gt;
&lt;span class="go"&gt;ubuntu-hirsute 5.11.0-37-generic&lt;/span&gt;
&lt;span class="go"&gt;ï¹© clang -v&lt;/span&gt;
&lt;span class="go"&gt;Ubuntu clang version 12.0.0-3ubuntu1~21.04.2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Then I made sure the execsnoop program from BCC toolkit showed new processes
(it prints one line for every &lt;code&gt;execve&lt;/code&gt; syscall),
so I could compare its output later with the Go implementation.&lt;/p&gt;
&lt;p&gt;The ELF binary &lt;code&gt;execsnoop&lt;/code&gt; was copied from a Docker container to the virtual machine as follows.
In case you wanted to build the image yourself,
here is a &lt;a href="https://gist.github.com/marselester/ac8e4262742c90539c8c53f37d9a6965"&gt;Dockerfile&lt;/a&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;ï¹ª docker run --name libbpf marselester/libbpf-tools:latest&lt;/span&gt;
&lt;span class="go"&gt;ï¹ª docker cp libbpf:/opt/execsnoop .&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The execsnoop captured &lt;code&gt;sshd&lt;/code&gt; and &lt;code&gt;ls&lt;/code&gt; processes, nice!&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;ï¹© sudo /vagrant/execsnoop&lt;/span&gt;
&lt;span class="go"&gt;PCOMM            PID    PPID   RET ARGS&lt;/span&gt;
&lt;span class="go"&gt;sshd             21254  832      0 /usr/sbin/sshd -D -R&lt;/span&gt;
&lt;span class="go"&gt;ls               21361  21351    0 /usr/bin/ls --color=auto&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;It can be useful to check for short-lived processes that consume CPU resources,
e.g., slow or failing application/container startup.&lt;/p&gt;
&lt;h2&gt;Embedding BPF in Go&lt;/h2&gt;
&lt;p&gt;My search for a BPF Go library stopped at &lt;a href="https://github.com/cilium/ebpf"&gt;github.com/cilium/ebpf&lt;/a&gt;
since it had several examples to build upon, and folks from Cilium were &lt;a href="https://github.com/cilium/ebpf/issues/303"&gt;very helpful&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The repository also contains &lt;a href="https://github.com/cilium/ebpf/tree/master/cmd/bpf2go"&gt;bpf2go&lt;/a&gt; tool to compile a BPF C source file into BPF bytecode.
It emits Go files containing compiled BPF for little and big endian systems.&lt;/p&gt;
&lt;p&gt;I copied &lt;a href="https://github.com/iovisor/bcc/blob/master/libbpf-tools/execsnoop.bpf.c"&gt;execsnoop.bpf.c&lt;/a&gt;,
&lt;a href="https://github.com/iovisor/bcc/blob/master/libbpf-tools/execsnoop.h"&gt;execsnoop.h&lt;/a&gt; files from BCC toolkit
and tried to generate Go files.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;ï¹© cd /vagrant/&lt;/span&gt;
&lt;span class="go"&gt;ï¹© mkdir -p cmd/execsnoop/bpf/&lt;/span&gt;
&lt;span class="go"&gt;ï¹© curl -o cmd/execsnoop/bpf/execsnoop.bpf.c https://raw.githubusercontent.com/iovisor/bcc/master/libbpf-tools/execsnoop.bpf.c&lt;/span&gt;
&lt;span class="go"&gt;ï¹© curl -o cmd/execsnoop/bpf/execsnoop.h https://raw.githubusercontent.com/iovisor/bcc/master/libbpf-tools/execsnoop.h&lt;/span&gt;
&lt;span class="go"&gt;ï¹© cat &amp;gt; cmd/execsnoop/main.go &amp;lt;&amp;lt;&amp;lt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="go"&gt;package main&lt;/span&gt;

&lt;span class="go"&gt;//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -cflags $BPF_CFLAGS -cc clang-12 ExecSnoop ./bpf/execsnoop.bpf.c -- -I../../headers&lt;/span&gt;

&lt;span class="go"&gt;func main() {}&lt;/span&gt;
&lt;span class="go"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="go"&gt;ï¹© go mod init execsnoop&lt;/span&gt;
&lt;span class="go"&gt;ï¹© go get github.com/cilium/ebpf/cmd/bpf2go&lt;/span&gt;
&lt;span class="go"&gt;ï¹© go generate ./cmd/execsnoop/&lt;/span&gt;
&lt;span class="go"&gt;/vagrant/cmd/execsnoop/bpf/execsnoop.bpf.c:2:10: fatal error: &amp;#39;vmlinux.h&amp;#39; file not found&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Unfortunately that didn't work because the &lt;code&gt;vmlinux.h&lt;/code&gt; header was missing.
This file contains kernel's type definitions that can be generated from the installed kernel using bpftool tool.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;ï¹© sudo apt-get install linux-tools-$(uname -r) linux-tools-common&lt;/span&gt;
&lt;span class="go"&gt;ï¹© bpftool btf dump file /sys/kernel/btf/vmlinux format c &amp;gt; ./headers/vmlinux.h&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;There were three more header files missing that I copied from ubuntu-kernel and libbpf repositories.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;ï¹© mkdir -p headers/bpf/&lt;/span&gt;
&lt;span class="go"&gt;ï¹© curl -o ./headers/bpf/bpf_helpers.h https://git.launchpad.net/~ubuntu-kernel/ubuntu/+source/linux/+git/hirsute/plain/tools/lib/bpf/bpf_helpers.h&lt;/span&gt;
&lt;span class="go"&gt;ï¹© curl -o ./headers/bpf/bpf_helper_defs.h https://raw.githubusercontent.com/libbpf/libbpf/master/src/bpf_helper_defs.h&lt;/span&gt;
&lt;span class="go"&gt;ï¹© curl -o ./headers/bpf/bpf_core_read.h https://git.launchpad.net/~ubuntu-kernel/ubuntu/+source/linux/+git/hirsute/plain/tools/lib/bpf/bpf_core_read.h&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Finally the Go files were generated and the BPF program was loaded into the kernel from an ELF.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;ï¹© go generate ./cmd/execsnoop/&lt;/span&gt;
&lt;span class="go"&gt;Compiled /vagrant/cmd/execsnoop/execsnoop_bpfel.o&lt;/span&gt;
&lt;span class="go"&gt;Wrote /vagrant/cmd/execsnoop/execsnoop_bpfel.go&lt;/span&gt;
&lt;span class="go"&gt;Compiled /vagrant/cmd/execsnoop/execsnoop_bpfeb.o&lt;/span&gt;
&lt;span class="go"&gt;Wrote /vagrant/cmd/execsnoop/execsnoop_bpfeb.go&lt;/span&gt;
&lt;span class="go"&gt;ï¹© sudo go run ./cmd/execsnoop/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Note, bpf2go tool uses Clang to compile the BPF program:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-cflags $BPF_CFLAGS&lt;/code&gt; are flags passed to the compiler from the &lt;code&gt;$BPF_CFLAGS&lt;/code&gt; env var,
  for example, &lt;code&gt;BPF_CFLAGS='-D__TARGET_ARCH_x86' go generate&lt;/code&gt; is expected in
  &lt;a href="https://elixir.bootlin.com/linux/latest/source/tools/lib/bpf/bpf_tracing.h#L5"&gt;bpf_tracing.h&lt;/a&gt; header
  (it is not used in execsnoop though)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-cc clang-12&lt;/code&gt; is a Clang binary name&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ExecSnoop&lt;/code&gt; is a name used by a code generation&lt;/li&gt;
&lt;li&gt;&lt;code&gt;./bpf/execsnoop.bpf.c&lt;/code&gt; is a path to the BPF C file that is compiled&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-- -I../../headers&lt;/code&gt; are compiler options that indicate where to find header files&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;log&amp;quot;&lt;/span&gt;

    &lt;span class="s"&gt;&amp;quot;golang.org/x/sys/unix&amp;quot;&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -cflags $BPF_CFLAGS -cc clang-12 ExecSnoop ./bpf/execsnoop.bpf.c -- -I../../headers&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Increase the resource limit of the current process to provide sufficient space&lt;/span&gt;
    &lt;span class="c1"&gt;// for locking memory for the BPF maps.&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;unix&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Setrlimit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;unix&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;RLIMIT_MEMLOCK&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;unix&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Rlimit&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;Cur&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;unix&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;RLIM_INFINITY&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;Max&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;unix&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;RLIM_INFINITY&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;});&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;failed to set temporary RLIMIT_MEMLOCK: %v&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;// Load the BPF program into the kernel from an ELF.&lt;/span&gt;
    &lt;span class="c1"&gt;// ExecSnoopObjects contains all objects (BPF programs and maps) after they have been loaded into the kernel:&lt;/span&gt;
    &lt;span class="c1"&gt;// TracepointSyscallsSysEnterExecve and TracepointSyscallsSysExitExecve BPF programs,&lt;/span&gt;
    &lt;span class="c1"&gt;// Events and Execs BPF maps.&lt;/span&gt;
    &lt;span class="nx"&gt;objs&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;ExecSnoopObjects&lt;/span&gt;&lt;span class="p"&gt;{}&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;LoadExecSnoopObjects&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;objs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;failed to load BPF programs and maps: %v&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;defer&lt;/span&gt; &lt;span class="nx"&gt;objs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;Tracepoints&lt;/h2&gt;
&lt;p&gt;The BPF program is executed on events such as tracepoints.
Tracepoint is a static instrumentation (hard-coded to the source code) of the Linux kernel,
see &lt;code&gt;/sys/kernel/debug/tracing/events&lt;/code&gt; to find available tracepoints.&lt;/p&gt;
&lt;p&gt;From looking at BPF C source file &lt;code&gt;execsnoop.bpf.c&lt;/code&gt; we can see two tracepoints instrumented:
the entry and the return of the &lt;code&gt;execve&lt;/code&gt; syscall so that
the process ID, command name, arguments, and the return value can be printed.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;SEC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;tracepoint/syscalls/sys_enter_execve&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;tracepoint__syscalls__sys_enter_execve&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;trace_event_raw_sys_enter&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;SEC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;tracepoint/syscalls/sys_exit_execve&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;tracepoint__syscalls__sys_exit_execve&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;trace_event_raw_sys_exit&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;SEC&lt;/code&gt; declares an ELF section named &lt;code&gt;tracepoint/syscalls/sys_enter_execve&lt;/code&gt;, followed by a BPF program.
A user-level loader may use this section header to determine where to attach a program.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tracepoint__syscalls__sys_enter_execve&lt;/code&gt; function is called for the tracepoint event.
The struct &lt;code&gt;trace_event_raw_sys_enter&lt;/code&gt; argument contains register state and BPF context.
From the registers, function arguments &lt;code&gt;ctx-&amp;gt;args&lt;/code&gt; and return value &lt;code&gt;ctx-&amp;gt;ret&lt;/code&gt; can be read.&lt;/p&gt;
&lt;p&gt;On Go side I attached the BPF program to &lt;code&gt;syscalls/sys_enter_execve&lt;/code&gt; tracepoint using &lt;code&gt;github.com/cilium/ebpf/link&lt;/code&gt; package.
The &lt;code&gt;link.Tracepoint()&lt;/code&gt; function returns a link (it represents a program attached to a BPF hook)
which is later used to detach the program.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nx"&gt;tpEnter&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;link&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Tracepoint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;syscalls&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;sys_enter_execve&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;objs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ExecSnoopPrograms&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;TracepointSyscallsSysEnterExecve&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;failed to attach the BPF program to sys_enter_execve tracepoint: %v&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;defer&lt;/span&gt; &lt;span class="nx"&gt;tpEnter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="nx"&gt;tpExit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;link&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Tracepoint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;syscalls&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;sys_exit_execve&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;objs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ExecSnoopPrograms&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;TracepointSyscallsSysExitExecve&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;failed to attach the BPF program to sys_exit_execve tracepoint: %v&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;defer&lt;/span&gt; &lt;span class="nx"&gt;tpExit&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code&gt;bpf_perf_event_output()&lt;/code&gt; C function emits records to user space via a BPF map &lt;code&gt;events&lt;/code&gt;
that accesses perf per-CPU ring buffers.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;__uint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BPF_MAP_TYPE_PERF_EVENT_ARRAY&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;__uint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key_size&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u32&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;__uint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value_size&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u32&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;events&lt;/span&gt; &lt;span class="n"&gt;SEC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;.maps&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;bpf_perf_event_output&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;events&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BPF_F_CURRENT_CPU&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In user space the events are read using &lt;code&gt;github.com/cilium/ebpf/perf&lt;/code&gt; package.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// Open a perf event reader from user space on the PERF_EVENT_ARRAY map&lt;/span&gt;
&lt;span class="c1"&gt;// defined in the BPF C program.&lt;/span&gt;
&lt;span class="nx"&gt;rd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;perf&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;NewReader&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;objs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ExecSnoopMaps&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Events&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Getpagesize&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;failed to create perf event reader: %v&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;defer&lt;/span&gt; &lt;span class="nx"&gt;rd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;record&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;rd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Read&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;perf&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;IsClosed&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;failed to read from perf ring buffer: %v&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;received from perf ring buffer: %s&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;record&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;RawSample&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In order to verify that the events are captured, I ran the Go program and &lt;code&gt;ls&lt;/code&gt; in another terminal.
Luckily it worked!&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;ï¹© sudo go run ./cmd/execsnoop/&lt;/span&gt;
&lt;span class="go"&gt;received from perf ring buffer: ?????ls/usr/bin/ls--color=auto&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;Decoding events&lt;/h2&gt;
&lt;p&gt;I wanted to match the output of the original execsnoop program, for that I needed to decode &lt;code&gt;record.RawSample&lt;/code&gt;
which contains bytes of the &lt;code&gt;event&lt;/code&gt; C struct into a Go struct.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;pid_t&lt;/span&gt; &lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;pid_t&lt;/span&gt; &lt;span class="n"&gt;ppid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;uid_t&lt;/span&gt; &lt;span class="n"&gt;uid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;int32&lt;/span&gt; &lt;span class="n"&gt;retval&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// it&amp;#39;s int in https://raw.githubusercontent.com/iovisor/bcc/master/libbpf-tools/execsnoop.h&lt;/span&gt;
    &lt;span class="n"&gt;int32&lt;/span&gt; &lt;span class="n"&gt;args_count&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// int&lt;/span&gt;
    &lt;span class="n"&gt;u32&lt;/span&gt; &lt;span class="n"&gt;args_size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// unsigned int&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;comm&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7680&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Go &lt;code&gt;event&lt;/code&gt; struct represents a perf event sent to user space from the BPF program running in the kernel.
Note, that it should match the C event struct, and both C and Go structs must be aligned the same way.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;event&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// PID is the process ID.&lt;/span&gt;
    &lt;span class="nx"&gt;PID&lt;/span&gt; &lt;span class="kt"&gt;int32&lt;/span&gt;
    &lt;span class="c1"&gt;// PPID is the process ID of the parent of this process.&lt;/span&gt;
    &lt;span class="nx"&gt;PPID&lt;/span&gt; &lt;span class="kt"&gt;int32&lt;/span&gt;
    &lt;span class="c1"&gt;// UID is the process user ID, e.g., 1000.&lt;/span&gt;
    &lt;span class="nx"&gt;UID&lt;/span&gt; &lt;span class="kt"&gt;uint32&lt;/span&gt;
    &lt;span class="c1"&gt;// Retval is the return value of the execve().&lt;/span&gt;
    &lt;span class="nx"&gt;Retval&lt;/span&gt; &lt;span class="kt"&gt;int32&lt;/span&gt;
    &lt;span class="c1"&gt;// ArgsCount is a number of arguments.&lt;/span&gt;
    &lt;span class="nx"&gt;ArgsCount&lt;/span&gt; &lt;span class="kt"&gt;int32&lt;/span&gt;
    &lt;span class="c1"&gt;// ArgSize is a size of arguments in bytes.&lt;/span&gt;
    &lt;span class="nx"&gt;ArgsSize&lt;/span&gt; &lt;span class="kt"&gt;uint32&lt;/span&gt;
    &lt;span class="c1"&gt;// Comm is the parent process/command name, e.g., bash.&lt;/span&gt;
    &lt;span class="nx"&gt;Comm&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="kt"&gt;byte&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The variable length &lt;code&gt;args&lt;/code&gt; field is omitted on Go side and decoded manually,
because I kept getting &lt;code&gt;failed to parse perf event: unexpected EOF error&lt;/code&gt;.
Perhaps the Go program got trailing garbage from the ring buffer which couldn't be unmarshalled.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// The data submitted via bpf_perf_event_output.&lt;/span&gt;
&lt;span class="c1"&gt;// Due to a kernel bug, this can contain between 0 and 7 bytes of trailing&lt;/span&gt;
&lt;span class="c1"&gt;// garbage from the ring depending on the input sample&amp;#39;s length.&lt;/span&gt;
&lt;span class="c1"&gt;// See https://pkg.go.dev/github.com/cilium/ebpf/perf#Record.&lt;/span&gt;
&lt;span class="nx"&gt;RawSample&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="kt"&gt;byte&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Timo Beckers in Cilium's Slack channel recommended to check alignment and hand-write an unmarshaller.
Here you can find my attempts to verify alignments &lt;a href="https://github.com/marselester/libbpf-tools/pull/3"&gt;#3&lt;/a&gt;
with alignchecker program.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Everything up until ArgsCount should be aligned on 8 bytes, but I'd expect the Go compiler to insert 4 bytes of padding between ArgsSize and Args, which would lead to an underrun on the C side. I've found hand-writing binary unmarshalers for these structs to be the most robust, but also the most annoying if your event format changes frequently.&lt;/p&gt;
&lt;p&gt;Cilium has a few alignchecker.go files if you're looking to dive deeper, we compare the DWARF info from the eBPF ELFs to Go struct fields annotated with align tags to make sure C and Go alignment corresponds&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;binary.Read()&lt;/code&gt; is used to read structured binary data from &lt;code&gt;record.RawSample&lt;/code&gt; into the &lt;code&gt;event&lt;/code&gt; struct.
The remaining bytes belong to &lt;code&gt;args&lt;/code&gt; field and just printed.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// eventSize is the event struct size in bytes, i.e., unsafe.Sizeof(e).&lt;/span&gt;
&lt;span class="c1"&gt;// It&amp;#39;s used to obtain the variable length args from the perf record.&lt;/span&gt;
&lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;eventSize&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;40&lt;/span&gt;

&lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%-16s %-6s %-6s %3s %s\n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;PCOMM&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;PID&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;PPID&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;RET&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;ARGS&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;record&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;rd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Read&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;perf&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;IsClosed&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;failed to read from perf ring buffer: %v&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;record&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;LostSamples&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ring event perf buffer is full, dropped %d samples&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;record&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;LostSamples&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;continue&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;e&lt;/span&gt; &lt;span class="nx"&gt;event&lt;/span&gt;
    &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;binary&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="nx"&gt;bytes&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;NewBuffer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;record&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;RawSample&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="nx"&gt;binary&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;LittleEndian&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;e&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;failed to parse perf event: %v&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;continue&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="nx"&gt;args&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;record&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;RawSample&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;eventSize&lt;/span&gt;&lt;span class="p"&gt;:]&lt;/span&gt;

    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;%-16s %-6d %-6d %3d %s\n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;bytes&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;TrimRight&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Comm&lt;/span&gt;&lt;span class="p"&gt;[:],&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;\x00&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="nx"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;PID&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;PPID&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Retval&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;strings&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ReplaceAll&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="nb"&gt;string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;bytes&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Trim&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;\x00&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt;
            &lt;span class="s"&gt;&amp;quot;\x00&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The resulting output of the Go execsnoop program is very close to the original ðŸŽ‰.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;ï¹© sudo go run ./cmd/execsnoop/&lt;/span&gt;
&lt;span class="go"&gt;PCOMM            PID    PPID   RET ARGS&lt;/span&gt;
&lt;span class="go"&gt;ls               69672  60093    0 /usr/bin/ls --color=auto&lt;/span&gt;
&lt;span class="go"&gt;sh               69783  69782    0 /bin/sh -c    cd / &amp;amp;&amp;amp; run-parts --report /etc/cron.hourly&lt;/span&gt;
&lt;span class="go"&gt;run-parts        69784  69783    0 /usr/bin/run-parts --report /etc/cron.hourly&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;You can find all the source code at
&lt;a href="https://github.com/marselester/libbpf-tools"&gt;github.com/marselester/libbpf-tools&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Appendix&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.brendangregg.com/bpf-performance-tools-book.html"&gt;BPF performance tools&lt;/a&gt; book
aided to navigate BPF C code.
Here are a few notes that are relevant to execsnoop program.&lt;/p&gt;
&lt;p&gt;A BPF program has to use &lt;a href="https://elixir.bootlin.com/linux/v5.11/source/include/uapi/linux/bpf.h#L712"&gt;helpers&lt;/a&gt;
because it can't access arbitrary memory (outside of BPF) and can't call arbitrary kernel functions.
The &lt;code&gt;execsnoop.bpf.c&lt;/code&gt; makes use of the following helpers.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bpf_probe_read_user(dst, size, unsafe_ptr)&lt;/code&gt; safely attempts to read &lt;em&gt;size&lt;/em&gt; bytes from user space address
&lt;em&gt;unsafe_ptr&lt;/em&gt; and stores the data in &lt;em&gt;dst&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bpf_get_current_pid_tgid()&lt;/code&gt; returns an unsigned 64-bit integer containing the current TGID (what user space calls the PID) in the upper bits
and the current PID (what user space calls the kernel thread ID) in the lower bits.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;u64&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bpf_get_current_pid_tgid&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="kt"&gt;pid_t&lt;/span&gt; &lt;span class="n"&gt;pid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;pid_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;pid_t&lt;/span&gt; &lt;span class="n"&gt;tgid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tgid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;bpf_get_current_uid_gid()&lt;/code&gt; returns a u64 integer containing the current GID in the upper bits
and UID in the lower bits.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;uid_t&lt;/span&gt; &lt;span class="n"&gt;uid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u32&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;bpf_get_current_uid_gid&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;bpf_get_current_task()&lt;/code&gt; returns a pointer to the current (on-CPU)
&lt;a href="https://elixir.bootlin.com/linux/v5.11/source/include/linux/sched.h#L649"&gt;task struct&lt;/a&gt; (a process).
This contains many details about the running process and links to other structs containing system state.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;task_struct&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;task_struct&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;bpf_get_current_task&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;bpf_get_current_comm(buf, buf_size)&lt;/code&gt; copies the task name to the buffer.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;bpf_get_current_comm&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;comm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;comm&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;bpf_perf_event_output(ctx, map, data, size)&lt;/code&gt; writes data to the &lt;code&gt;perf_event&lt;/code&gt; ring buffers;
this is used for per-event output.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bpf_map_lookup_elem(map, key)&lt;/code&gt; finds a key in a map and returns its value (pointer).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bpf_map_lookup_elem&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;execs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;bpf_map_update_elem(map, key, value, flags)&lt;/code&gt; atomically updates the value of the entry selected by key.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt; &lt;span class="n"&gt;empty_event&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;__uint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BPF_MAP_TYPE_HASH&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;__uint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max_entries&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10240&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;__type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;pid_t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;__type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;execs&lt;/span&gt; &lt;span class="n"&gt;SEC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;.maps&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bpf_map_update_elem&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;execs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;empty_event&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BPF_NOEXIST&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The &lt;em&gt;execs&lt;/em&gt; is declared of type &lt;code&gt;BPF_MAP_TYPE_HASH&lt;/code&gt; (a hash table).
The key is a &lt;code&gt;pid_t&lt;/code&gt;, and the value is struct &lt;code&gt;event&lt;/code&gt;.
&lt;em&gt;BPF_NOEXIST&lt;/em&gt; flag specifies that the entry for key must not exist in the map.&lt;/p&gt;
&lt;p&gt;BPF supports the following map types:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BPF_MAP_TYPE_HASH&lt;/code&gt; is a hash table: key/value pairs&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BPF_MAP_TYPE_ARRAY&lt;/code&gt; is an array of elements&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BPF_MAP_TYPE_PERF_EVENT_ARRAY&lt;/code&gt; is an interface to the &lt;code&gt;perf_event&lt;/code&gt; ring buffers
  for emitting trace records to user space&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BPF_MAP_TYPE_PERCPU_HASH&lt;/code&gt; is a faster hash table maintained on a per-CPU basis&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BPF_MAP_TYPE_STACK_TRACE&lt;/code&gt; is a storage for stack traces, indexed by stack IDs&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BPF_MAP_TYPE_STACK&lt;/code&gt; is a storage for stack traces&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There are three ways to output data from kernel to user:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BPF_PERF_OUTPUT()&lt;/code&gt; is a way to send per-event details to user space, via a custom struct you define.&lt;/li&gt;
&lt;li&gt;BPF maps using &lt;code&gt;bpf_perf_event_output()&lt;/code&gt; (periodically read from user space)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bpf_trace_printk()&lt;/code&gt; writes to trace_pipe (debugging only).
  I wasn't sure about &lt;code&gt;pid_t&lt;/code&gt; size so I used &lt;code&gt;bpf_printk("the PID is %d", sizeof(pid));&lt;/code&gt;
  and printed the trace buffer as follows (see &lt;a href="https://nakryiko.com/posts/bpf-tips-printk/"&gt;BPF tips &amp;amp; tricks&lt;/a&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="go"&gt;ï¹© sudo cat /sys/kernel/debug/tracing/trace_pipe&lt;/span&gt;
&lt;span class="go"&gt;&amp;lt;...&amp;gt;-487422  [001] .... 544705.474270: 0: the PID is 4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="bpf"></category><category term="golang"></category></entry><entry><title>How to Structure Go Projects</title><link href="https://marselester.com/how-to-structure-go-projects.html" rel="alternate"></link><published>2018-09-28T00:00:00+07:00</published><updated>2018-09-28T00:00:00+07:00</updated><author><name>Marsel Mavletkulov</name></author><id>tag:marselester.com,2018-09-28:/how-to-structure-go-projects.html</id><summary type="html">&lt;p&gt;I came to Go from Django where the framework defines project layout, thus I wanted to know
how to structure my Go applications. After reading documentation and building a few Django projects,
you get a clear mental picture, as most of the questions are already answered.
That helps to keep â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;I came to Go from Django where the framework defines project layout, thus I wanted to know
how to structure my Go applications. After reading documentation and building a few Django projects,
you get a clear mental picture, as most of the questions are already answered.
That helps to keep the projects within a company consistent, so developers don't have to struggle
when they land on a new codebase. I was looking for a similar framework approach in Go,
but none of them felt right to me. For some reason the same concepts do not resonate with Go.
I didn't have better ideas, so I watched a few videos from conferences.
Here are the talks I found most helpful and I use them as guidelines:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Ben Johnson's &lt;a class="reference external" href="https://www.youtube.com/watch?v=LMSbsW1Xpwg"&gt;Structuring Applications for Growth&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Brian Ketelsen's &lt;a class="reference external" href="https://www.youtube.com/watch?v=MzTcsI6tn-0"&gt;Write Code Like the Go Team&lt;/a&gt;,
&lt;a class="reference external" href="https://talks.bjk.fyi/gcru18-best.html#/"&gt;slides&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Kat Zien's &lt;a class="reference external" href="https://www.youtube.com/watch?v=oL6JBUk6tj0"&gt;How Do You Structure Your Go Apps&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Peter Bourgon's &lt;a class="reference external" href="https://www.youtube.com/watch?v=LHe1Cb_Ud_M"&gt;Ways To Do Things&lt;/a&gt;.
I tried his ideas in &lt;a class="reference external" href="https://github.com/marselester/rascaldb/blob/master/rascaldb.go"&gt;RascalDB ðŸ˜œ&lt;/a&gt;
to serialize concurrent DB actions.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I encourage you to watch those talks and go over code examples they provided.&lt;/p&gt;
&lt;p&gt;The following is my takeaway which could be completely misleading and far from the original ideas
(just in case, you don't have to apply all of them together).
If you feel something doesn't bring enough value in your case, just skip it, trust your intuition.
Development requires many iterations to bounce ideas until the result becomes good enough.&lt;/p&gt;
&lt;div class="section" id="know-your-domain"&gt;
&lt;h2&gt;Know Your Domain&lt;/h2&gt;
&lt;p&gt;I like to start a new project on A4 paper and dump everything I know in free form
(what the problem are you facing, can you solve it without writing code,
what are possible solutions (pros/cons), terminology, system requirements, API endpoints, sketches,
doodles, whatever gets your train of thoughts moving). Paper helps to get away from constraints of computer,
I can write and draw without any programs which would otherwise have taken time and stolen my brain cycles.
Paper helps me to stay focused â€” nothing blinks, pops up or rings, there is no urge to multitask
(check email/Slack, switch between editor and console as if there is something new).&lt;/p&gt;
&lt;p&gt;Once you wrote everything down, you might realize there is not enough information to make progress.
So you can reach out to stake holders and get more insights using your notes.
Don't forget to write new info as well. It might take a few iterations when you finally establish
common terminology, refine the actual project's goal, and cut unnecessary features/requirements.&lt;/p&gt;
&lt;p&gt;Now you have a mental picture of the project with clear deliverables.
Based on that I like to spend time to come up with a concise project/repository name which
summarizes nicely the project's goal and spirit (thesaurus comes to the rescue).
As a next step I usually create README file where insights from the paper are documented.
This time you want everyone in the world to understand what you learned about the project.
This helps you to iterate once more as you're documenting in README, and the end result
can be shared with coworkers (they might not understand your handwriting and doodles).
If they have questions, that means you have a room for improvement, since other people
don't have a context you obtained. Take your time and write it down, this will ensure that
you will be able to get help with the project much easier (when you're on vacation or
have to hand over the code). With some practice you'll anticipate questions and
provide answers in README, so it won't take as much time from your coworkers next time.
Keeping in mind that you are ultimately solving problems for your customers and
designing the system and writing code for your coworkers (not just for yourself)
helps to rigorously document as you go. Or else prepare to answer the same questions
over and over again. In order to get better at documenting, I recommend reading
&lt;a class="reference external" href="http://www.writethedocs.org/guide/writing/beginners-guide-to-docs/"&gt;A beginnerâ€™s guide to writing documentation&lt;/a&gt;
and &lt;a class="reference external" href="http://www.writethedocs.org/guide/"&gt;Documentation Guide&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Let's say you're building an API client, then it makes sense to start from
a usage example in the README, since most of the documentation work is done by API provider.
How will people download your library? How will they import it, does the path look concise and clear?
How will your end user configure a client? What use cases your users might have (custom API domain,
timeouts, logging, instrumentation)? Think of a few workflows and see how would you handle errors.
Best case scenario is using your own library to reveal pain points.
Check out &lt;a class="reference external" href="https://github.com/marselester/bitgo-v2"&gt;one of my attempts&lt;/a&gt; to find a decent layout of
an API library. The library has a configurable client (you can instantiate many of them, e.g., one per coin)
which allows to use a custom logger, http.Client, etc. It also has embedded services â€” things that know
how to speak with particular API endpoints to operate API resources.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="getting-to-the-point"&gt;
&lt;h2&gt;Getting to the Point&lt;/h2&gt;
&lt;p&gt;As you can see from the talks the main theme in Go application structure is heavily
influenced by Domain-Driven Design (DDD). Using the research done on your project,
you shall write down entities (as Go structs) of the domain model and services (as Go interfaces)
which perform operations over those entities.&lt;/p&gt;
&lt;p&gt;I should mention that for simplicity's sake in my projects I decided to combine DDD &amp;quot;service&amp;quot; and
&amp;quot;repository&amp;quot; concepts under &amp;quot;service&amp;quot; term.&lt;/p&gt;
&lt;p&gt;Let's proceed with listing minimal set of operations over the key entities to keep the scope small.
It helps to imagine that there are different service implementations,
an entity can be stored anywhere, for example, in Postgres, Kafka, memory, Redis,
JSON file, remote API. But keep in mind semantics that storage of choice provides:
getting a list of entities from Kafka and Postgres are hard to abstract (streaming vs quering).
Moreover, if you do so, you might create unnecessary constraints for yourself.
In reality, it is very unlikely that a project will change storages often,
since you've chosen them for a reason (the choice of the storage is influenced
by a problem you're solving, its constraints and guarantees you need).
Most likely you've already chosen the storages in advance, so make sure you
don't fight with interfaces you defined in your domain model. If you know your services
need to share the same SQL transaction, embrace it in interfaces, for instance:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;PaymentService&lt;/span&gt; &lt;span class="kd"&gt;interface&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nx"&gt;CreatePayment&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;ctx&lt;/span&gt; &lt;span class="nx"&gt;context&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;tx&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;sql&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Tx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;Payment&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kt"&gt;error&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Do you put all operations (add/list) into one service interface? I don't know.
You have to decide. If you add an entity to Postgres, you expect to list them
from Postgres as well. From this perspective &amp;quot;add&amp;quot; and &amp;quot;list&amp;quot; operations should be
under the same interface. If in-memory storage can't implement the service interface,
perhaps you don't have to enforce operation under the same interface,
then probably it's ok to split it.&lt;/p&gt;
&lt;p&gt;Ben Johnson defines entities in a single package where domain model is described â€” the package
shouldnâ€™t have third party dependencies. Whereas Kat Zien in her demo created a package per service:
&amp;quot;adder&amp;quot; package that adds beers and reviews, &amp;quot;lister&amp;quot; service lists beers and reviews.
Each package defines its own beer and review structs.&lt;/p&gt;
&lt;p&gt;In my projects I isolate services implementation in a single package.
For example, if I stored beer reviews in Kafka, I would have a kafka package which exposes
a client and beer/review services embedded in it. The same applies to postgres package â€” two services use
the same db connection pool and beer/review entities might appear in the same db transaction.&lt;/p&gt;
&lt;p&gt;During coding I combine the service implementations into a program (some server or
a ctl tool) kept in cmd directory. That helps me to validate design ideas and notice any awkward
component integrations. Similar to service implementations, try to think where the input and
output could be coming from/to: standard input/output, http, rpc, db.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="an-example"&gt;
&lt;h2&gt;An Example&lt;/h2&gt;
&lt;p&gt;Now let's have a look at &lt;a class="reference external" href="https://github.com/marselester/distributed-payment"&gt;distributed payment&lt;/a&gt;
demo project where I explored an idea of payment transaction
without atomic commit across 3 Kafka partitions.&lt;/p&gt;
&lt;p&gt;The domain model is defined in the repository root (note, you can place your packages
in &amp;quot;internal&amp;quot; directory, so you don't mix them up with unrelated files):&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;cite&gt;wallet.go&lt;/cite&gt; has &lt;cite&gt;Transfer&lt;/cite&gt;, &lt;cite&gt;Payment&lt;/cite&gt; entities, and services &lt;cite&gt;TransferService&lt;/cite&gt;, &lt;cite&gt;PaymentService&lt;/cite&gt;
which can create and list the entities. Since the project is based on Kafka,
the interfaces reflect that (&lt;cite&gt;partition&lt;/cite&gt;, &lt;cite&gt;offset&lt;/cite&gt; params). The services accept &lt;cite&gt;context.Context&lt;/cite&gt;
as a first argument, because we should be able to tell implementations to cancel operation.
&lt;a class="reference external" href="https://github.com/opentracing/opentracing-go"&gt;OpenTracing&lt;/a&gt; can leverage context as well.
Pay attention to a pointer/value semantics (share or not) in the service interfaces.
Since an entity in DDD terms has a unique identity, a pointer semantics was used,
hence &lt;cite&gt;*Transfer&lt;/cite&gt; is passed to &lt;cite&gt;CreateTransfer()&lt;/cite&gt; and returned from &lt;cite&gt;FromOffset()&lt;/cite&gt;. Have a look at
&lt;a class="reference external" href="https://www.ardanlabs.com/blog/2017/06/design-philosophy-on-data-and-semantics.html"&gt;Design Philosophy On Data And Semantics&lt;/a&gt;
for more insights.&lt;/li&gt;
&lt;li&gt;&lt;cite&gt;error.go&lt;/cite&gt; contains errors which are relevant to the whole domain model,
&lt;a class="reference external" href="https://middlemost.com/failure-is-your-domain/"&gt;Failure is your Domain&lt;/a&gt;.
On implementation level there could be their own specific errors, for example, HTTP API errors in
&lt;cite&gt;rest/error.go&lt;/cite&gt; define JSON and validation errors.&lt;/li&gt;
&lt;li&gt;&lt;cite&gt;log.go&lt;/cite&gt; borrows &lt;cite&gt;Logger&lt;/cite&gt; interface from Go kit. Since logging is an integral part of the system,
placing it nearby the domain model seems justified. There is
&lt;a class="reference external" href="https://github.com/go-commons/commons/issues/1"&gt;Standard logger interface&lt;/a&gt; discussion
where the consensus is to emit events instead of logging in the library.
Best practices and examples of how to emit events is still an
&lt;a class="reference external" href="https://github.com/go-commons/event/issues/1"&gt;open topic&lt;/a&gt; at the time of writing.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Implementations of the services defined in &lt;cite&gt;wallet.go&lt;/cite&gt; are isolated in packages
by their dependency name, for example, kafka, rest, mock, rocksdb.&lt;/p&gt;
&lt;p&gt;Package kafka implements wallet services and provides the Client access to them.
There were two design options: embed the services to the Client struct or
inject a service into each other. The example below would allow to have
a swappable &lt;cite&gt;PaymentService&lt;/cite&gt; (&amp;quot;pg&amp;quot; refers to a Postgres implementation):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;kafka&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;TransferService&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;PaymentService&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;pg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;NewPaymentService&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;On the other hand, grouping services in the Client would let services maintain DB transactions
by sharing the same &lt;cite&gt;*sql.DB&lt;/cite&gt;. Here is &lt;cite&gt;pg.Client&lt;/cite&gt; example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// Client represents a client to the underlying PostgreSQL data store.&lt;/span&gt;
&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;Client&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nx"&gt;Transfer&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;TransferService&lt;/span&gt;
  &lt;span class="nx"&gt;Payment&lt;/span&gt;  &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;PaymentService&lt;/span&gt;

  &lt;span class="nx"&gt;logger&lt;/span&gt; &lt;span class="nx"&gt;wallet&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Logger&lt;/span&gt;

  &lt;span class="nx"&gt;db&lt;/span&gt;        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;sql&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;DB&lt;/span&gt;
  &lt;span class="nx"&gt;transferQ&lt;/span&gt; &lt;span class="kd"&gt;map&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;
  &lt;span class="nx"&gt;paymentQ&lt;/span&gt;  &lt;span class="kd"&gt;map&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In &lt;a class="reference external" href="https://github.com/marselester/distributed-signup/blob/master/pg/user_service.go"&gt;distributed-signup&lt;/a&gt;
project a Client concept is baked into &lt;cite&gt;UserService&lt;/cite&gt;, because it was the only service that
needed access to Postgres.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// UserService reprensets a service to store signed up users.&lt;/span&gt;
&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;UserService&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nx"&gt;config&lt;/span&gt; &lt;span class="nx"&gt;Config&lt;/span&gt;

  &lt;span class="nx"&gt;pool&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;pgx&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ConnPool&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Package rest is responsible for translating incoming HTTP requests to wallet domain and
then translating results from wallet model back to HTTP responses.
The package doesn't implement &lt;cite&gt;TransferService&lt;/cite&gt; per se, it uses one in its Server.
The REST-style API server itself is put together in
&lt;a class="reference external" href="https://github.com/marselester/distributed-payment/blob/master/cmd/transfer-server/main.go"&gt;cmd/transfer-server&lt;/a&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// Server represents an HTTP API handler for wallet services.&lt;/span&gt;
&lt;span class="c1"&gt;// It wraps a TransferService so we can provide different&lt;/span&gt;
&lt;span class="c1"&gt;// implementations, e.g., Kafka or a mock.&lt;/span&gt;
&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;Server&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;chi&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Mux&lt;/span&gt;
  &lt;span class="nx"&gt;logger&lt;/span&gt;          &lt;span class="nx"&gt;wallet&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Logger&lt;/span&gt;
  &lt;span class="nx"&gt;transferService&lt;/span&gt; &lt;span class="nx"&gt;wallet&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;TransferService&lt;/span&gt;
  &lt;span class="nx"&gt;wopts&lt;/span&gt;           &lt;span class="nx"&gt;walletOption&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Originally in &lt;a class="reference external" href="https://medium.com/wtf-dial/wtf-dial-http-api-d8800ccd605f"&gt;WTF Dial: HTTP API&lt;/a&gt;
Ben Johnson explained how to implement API properly and isolate http dependencies in wtf/http package.&lt;/p&gt;
&lt;p&gt;Package mock provides mock services to facilitate testing. For example, for most cases
we do not need Kafka implementation of a transfer service to be used in HTTP API testing.&lt;/p&gt;
&lt;p&gt;Package rocksdb implements user requests deduplication using RocksDB to
memorise already processed request IDs. Requests deduplication is an integral part of
a distributed system, hence the domain model must embrace it.&lt;/p&gt;
&lt;p&gt;Everything is connected in cmd directory. Note, that the domain package is used everywhere.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;cite&gt;cmd/transfer-server&lt;/cite&gt; is HTTP API server to create money transfers which are stored in Kafka.
It delegates the actual hard work to kafka and rest packages.&lt;/li&gt;
&lt;li&gt;&lt;cite&gt;cmd/paymentd&lt;/cite&gt; program is responsible for creating incoming &amp;amp; outgoing payment pairs based on
money transfer requests stored in Kafka.&lt;/li&gt;
&lt;li&gt;&lt;cite&gt;cmd/accountantd&lt;/cite&gt; is the last program in the pipeline. It sequentially reads Kafka messages
from &lt;cite&gt;wallet.payment&lt;/cite&gt; topic, deduplicates messages by request ID, and applies the changes to
the account balances. Deduplication is provided by rocksdb package mentioned above.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To wrap up, that's all I managed to recall :) I look forward for more talks on structuring Go applications.&lt;/p&gt;
&lt;/div&gt;
</content><category term="golang"></category><category term="project structure"></category><category term="Domain-Driven Design"></category></entry></feed>