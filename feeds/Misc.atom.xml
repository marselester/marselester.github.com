<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>marselester's blog</title><link href="http://marselester.github.com/" rel="alternate"></link><link href="http://marselester.github.com/feeds/Misc.atom.xml" rel="self"></link><id>http://marselester.github.com/</id><updated>2010-10-06T00:00:00+06:00</updated><entry><title>Вычислительные методы одномерной оптимизации</title><link href="http://marselester.github.com/computing-methods-of-one-dimensional-optimization.html" rel="alternate"></link><updated>2010-10-06T00:00:00+06:00</updated><author><name>Marsel Mavletkulov</name></author><id>tag:marselester.github.com,2010-10-06:computing-methods-of-one-dimensional-optimization.html</id><summary type="html">&lt;p&gt;На третьем курсе по предмету методы оптимизации делали лабораторную работу на
тему «Вычислительные методы одномерной оптимизации».
Задача заключалась в поиске безусловного минимума функции
&lt;tt class="docutils literal"&gt;f(x) = pow(x, 3) – x + pow(e, &lt;span class="pre"&gt;-x)&lt;/span&gt;&lt;/tt&gt; на начальном интервале &lt;tt class="docutils literal"&gt;[0, 1]&lt;/tt&gt;
с точностью &lt;tt class="docutils literal"&gt;0.00001&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Вычисления производились через:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;пассивный метод;&lt;/li&gt;
&lt;li&gt;равномерные блочные методы;&lt;/li&gt;
&lt;li&gt;метод золотого сечения;&lt;/li&gt;
&lt;li&gt;метод чисел Фибоначчи;&lt;/li&gt;
&lt;li&gt;метод касательной.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Наилучшим по количеству экспериментов оказался метод чисел Фибоначчи,
наихудшим – пассивный метод. Наилучшим по времени работы оказался метод
золотого сечения, наихудшим – пассивный метод. Так же было установлено, что
для данной функции блочный метод работает лучше с блоками размерами 3 и 8, для
нечетного и четного соответственно.&lt;/p&gt;
&lt;p&gt;Если кому-нибудь пригодилось – &lt;a class="reference external" href="https://dl.dropbox.com/u/15875449/fx.zip"&gt;архив с исходниками&lt;/a&gt; на php.&lt;/p&gt;
</summary><category term="php"></category><category term="mathematical optimization"></category></entry><entry><title>Определение нажатия комбинации клавиш средствами BIOS на ассемблере</title><link href="http://marselester.github.com/definition-of-pressing-of-a-combination-of-keys-by-means-BIOS-on-the-assembler.html" rel="alternate"></link><updated>2009-12-03T00:00:00+05:00</updated><author><name>Marsel Mavletkulov</name></author><id>tag:marselester.github.com,2009-12-03:definition-of-pressing-of-a-combination-of-keys-by-means-BIOS-on-the-assembler.html</id><summary type="html">&lt;p&gt;По учебе понадобилось написать программу на ассемблере, которая должна
распознать нажатие «горячей» комбинации клавиш &lt;tt class="docutils literal"&gt;LeftCtrl+RightShift+F3&lt;/tt&gt; и
реагировать на него звуковым сигналом. Информации/примеров по этой теме
маловато, по этому решил опубликовать свою программку.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
masm
.model small
.stack 256
.data
    Msg_about db 'Распознать нажатие «горячей» комбинации клавиш', 0Ah, 0Dh
              db 'LeftCtrl+RightShift+F3', 0Ah, 0Dh
              db 'и реагировать на него звуковым сигналом', 0Ah, 0Dh, '$'

.code

start:
    ; Инициализация сегментного регистра ds
    mov ax, &amp;#64;data
    mov ds, ax

    ; Видеорежим 3 (очистка экрана и установка курсора в 0, 0)
    mov ax, 0003h
    int 10h

    ; Вывод сообщения на экран
    mov ah, 9
    mov dx, offset Msg_about
    int 21h

    ; Чтение символа с ожиданием
    mov ah, 0
    int 16h

    ; Проверка нажатия Ctrl+F3
    cmp ah, 60h
    jne exit

    ; Получение состояния клавиатуры
    mov ah, 12h
    int 16h

    ; Проверка нажатия LeftCtrl
    test ah, 1b
    jz exit

    ; Проверка нажатия RightShift
    test al, 1b
    jz exit

    mov ah, 2 ; Вывод символа
    mov dl, 7 ; Сигнал
    int 21h

    ; Завершение программы, возврат управления ОС
    exit:
    mov ax, 4c00h
    int 21h
end start
&lt;/pre&gt;
&lt;p&gt;Для чтения символа используется функция &lt;tt class="docutils literal"&gt;16h BIOS&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;AH = 0&lt;/p&gt;
&lt;p&gt;На выходе в AL = ASCII-код символа, 0 или префикс скан-кода, АН = скан-код
нажатой клавиши или расширенный ASCII-код.&lt;/p&gt;
&lt;p&gt;Далее производится сравнение регистра AH со скан-кодом 60h (нажатие Ctrl+F3).&lt;/p&gt;
&lt;p&gt;Потом получаем состояния клавиатуры. Используется функция &lt;tt class="docutils literal"&gt;16h BIOS&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;AH = 12h&lt;/p&gt;
&lt;p&gt;На выходе в AX заносится состояние клавиатуры. Нас интересует только первый
бит AH (LeftCtrl) и первый бит AL (RightShift).&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;Состояние клавиатуры&lt;/h2&gt;
&lt;div class="section" id="al"&gt;
&lt;h3&gt;AL&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Бит 7: Ins&lt;/li&gt;
&lt;li&gt;Бит 6: CapsLock&lt;/li&gt;
&lt;li&gt;Бит 5: NumLock&lt;/li&gt;
&lt;li&gt;Бит 4: ScrollLock&lt;/li&gt;
&lt;li&gt;Бит 3: Alt (любой Alt для функции 02h, часто только левый Alt для 12h/22h)&lt;/li&gt;
&lt;li&gt;Бит 2: Ctrl (любой)&lt;/li&gt;
&lt;li&gt;Бит 1: LeftShift&lt;/li&gt;
&lt;li&gt;Бит 0: RightShift&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="ah"&gt;
&lt;h3&gt;AH&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Бит 7: SysRq&lt;/li&gt;
&lt;li&gt;Бит 6: CapsLock&lt;/li&gt;
&lt;li&gt;Бит 5: NumLock&lt;/li&gt;
&lt;li&gt;Бит 4: ScrollLock&lt;/li&gt;
&lt;li&gt;Бит 3: RightAlt&lt;/li&gt;
&lt;li&gt;Бит 2: RightCtrl&lt;/li&gt;
&lt;li&gt;Бит 1: LeftAlt&lt;/li&gt;
&lt;li&gt;Бит 0: LeftCtrl&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
</summary><category term="assembler"></category></entry><entry><title>Моделирование одноканальной СМО с отказами</title><link href="http://marselester.github.com/modeling-single-channel-queue-with-refusals.html" rel="alternate"></link><updated>2009-05-30T00:00:00+06:00</updated><author><name>Marsel Mavletkulov</name></author><id>tag:marselester.github.com,2009-05-30:modeling-single-channel-queue-with-refusals.html</id><summary type="html">&lt;p&gt;Дана одноканальная система массового обслуживания с отказами. В нее поступают
заявки через промежуток времени &lt;tt class="docutils literal"&gt;n&lt;/tt&gt;, где &lt;tt class="docutils literal"&gt;n&lt;/tt&gt; – случайная величина,
подчиненная равномерному закону распределения. Время обслуживания заявки
системой &lt;tt class="docutils literal"&gt;m&lt;/tt&gt; также является случайной величиной с показательным законом
распределения. Если к моменту прихода заявки канал занят, заявка покидает
систему необслуженной.&lt;/p&gt;
&lt;p&gt;Изначально код был написан на php, вот &lt;a class="reference external" href="https://github.com/marselester/single-channel-queuing"&gt;пример на python 3&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
import random


class RequestPoll:
    &amp;quot;&amp;quot;&amp;quot;Iterator that yields random requests and keeps statistic.&amp;quot;&amp;quot;&amp;quot;

    def __init__(self, time_to_finish, intensity_of_service_flow):
        self.time_to_finish = time_to_finish
        self.intensity_of_service_flow = intensity_of_service_flow

    def __str__(self):
        return (
            'Total: {}\n'.format(self.total()) +
            'Processed: {}\n'.format(self.qty_of_processed_requests) +
            'Refused: {}\n'.format(self.qty_of_refused_requests) +
            'Proportion of processed requests: {}\n'.format(self.proportion_of_processed_requests()) +
            'Probability of refuse: {}\n'.format(self.probability_of_refuse()) +
            'Absolute bandwidth: {}'.format(self.abs_bandwidth())
        )

    def __iter__(self):
        self.system_uptime = 0
        self.time_when_channel_will_be_free = 0
        self.qty_of_processed_requests = 0
        self.qty_of_refused_requests = 0
        return self

    def __next__(self):
        if self.system_uptime &amp;gt; self.time_to_finish:
            raise StopIteration
        time_when_request_came_in = random.random()
        self.system_uptime += time_when_request_came_in

        if self._can_system_process_request():
            self.qty_of_processed_requests += 1

            time_for_which_request_has_taken_channel = random \
                .expovariate(self.intensity_of_service_flow)
            self.time_when_channel_will_be_free = self.system_uptime \
                + time_for_which_request_has_taken_channel

            return 'request added to queue at {}'.format(self.system_uptime)
        else:
            self.qty_of_refused_requests += 1

            return 'requests refused at {}'.format(self.system_uptime)

    def _can_system_process_request(self):
        return self.system_uptime &amp;gt;= self.time_when_channel_will_be_free

    def total(self):
        return self.qty_of_processed_requests + self.qty_of_refused_requests

    def abs_bandwidth(self):
        return self.qty_of_processed_requests / self.time_to_finish

    def proportion_of_processed_requests(self):
        return self.qty_of_processed_requests / self.total()

    def probability_of_refuse(self):
        return self.qty_of_refused_requests / self.total()

intensity_of_service_flow = 0.5
time_to_finish = 70
request_poll = RequestPoll(time_to_finish, intensity_of_service_flow)

for request in request_poll:
    print(request)

print(request_poll)
&lt;/pre&gt;
</summary><category term="python"></category><category term="modeling"></category><category term="single-channel queue"></category></entry></feed>