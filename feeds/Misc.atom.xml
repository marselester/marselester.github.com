<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>marselester's blog</title><link href="http://marselester.github.com/" rel="alternate"></link><link href="http://marselester.github.com/feeds/Misc.atom.xml" rel="self"></link><id>http://marselester.github.com/</id><updated>2010-10-06T00:00:00+06:00</updated><entry><title>Вычислительные методы одномерной оптимизации</title><link href="http://marselester.github.com/computing-methods-of-one-dimensional-optimization.html" rel="alternate"></link><updated>2010-10-06T00:00:00+06:00</updated><author><name>Marsel Mavletkulov</name></author><id>tag:marselester.github.com,2010-10-06:computing-methods-of-one-dimensional-optimization.html</id><summary type="html">&lt;p&gt;На третьем курсе по предмету методы оптимизации делали лабораторную работу на
тему «Вычислительные методы одномерной оптимизации».
Задача заключалась в поиске безусловного минимума функции
&lt;tt class="docutils literal"&gt;f(x) = pow(x, 3) – x + pow(e, &lt;span class="pre"&gt;-x)&lt;/span&gt; на начальном интервале &lt;span class="pre"&gt;``[0,&lt;/span&gt; 1]&lt;/tt&gt;
с точностью &lt;tt class="docutils literal"&gt;0.00001&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Вычисления производились через:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;пассивный метод;&lt;/li&gt;
&lt;li&gt;равномерные блочные методы;&lt;/li&gt;
&lt;li&gt;метод золотого сечения;&lt;/li&gt;
&lt;li&gt;метод чисел Фибоначчи;&lt;/li&gt;
&lt;li&gt;метод касательной.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Наилучшим по количеству экспериментов оказался метод чисел Фибоначчи,
наихудшим – пассивный метод. Наилучшим по времени работы оказался метод
золотого сечения, наихудшим – пассивный метод. Так же было установлено, что
для данной функции блочный метод работает лучше с блоками размерами 3 и 8, для
нечетного и четного соответственно.&lt;/p&gt;
&lt;p&gt;Если кому-нибудь пригодилось – &lt;a class="reference external" href="https://dl.dropbox.com/u/15875449/fx.zip"&gt;архив с исходниками&lt;/a&gt; на php.&lt;/p&gt;
</summary><category term="php"></category><category term="mathematical optimization"></category></entry><entry><title>Определение нажатия комбинации клавиш средствами BIOS на ассемблере</title><link href="http://marselester.github.com/definition-of-pressing-of-a-combination-of-keys-by-means-BIOS-on-the-assembler.html" rel="alternate"></link><updated>2009-12-03T00:00:00+05:00</updated><author><name>Marsel Mavletkulov</name></author><id>tag:marselester.github.com,2009-12-03:definition-of-pressing-of-a-combination-of-keys-by-means-BIOS-on-the-assembler.html</id><summary type="html">&lt;p&gt;По учебе понадобилось написать программу на ассемблере, которая должна
распознать нажатие «горячей» комбинации клавиш &lt;tt class="docutils literal"&gt;LeftCtrl+RightShift+F3&lt;/tt&gt; и
реагировать на него звуковым сигналом. Информации/примеров по этой теме
маловато, по этому решил опубликовать свою программку.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
masm
.model small
.stack 256
.data
    Msg_about db 'Распознать нажатие «горячей» комбинации клавиш', 0Ah, 0Dh
              db 'LeftCtrl+RightShift+F3', 0Ah, 0Dh
              db 'и реагировать на него звуковым сигналом', 0Ah, 0Dh, '$'

.code

start:
    ; Инициализация сегментного регистра ds
    mov ax, &amp;#64;data
    mov ds, ax

    ; Видеорежим 3 (очистка экрана и установка курсора в 0, 0)
    mov ax, 0003h
    int 10h

    ; Вывод сообщения на экран
    mov ah, 9
    mov dx, offset Msg_about
    int 21h

    ; Чтение символа с ожиданием
    mov ah, 0
    int 16h

    ; Проверка нажатия Ctrl+F3
    cmp ah, 60h
    jne exit

    ; Получение состояния клавиатуры
    mov ah, 12h
    int 16h

    ; Проверка нажатия LeftCtrl
    test ah, 1b
    jz exit

    ; Проверка нажатия RightShift
    test al, 1b
    jz exit

    mov ah, 2 ; Вывод символа
    mov dl, 7 ; Сигнал
    int 21h

    ; Завершение программы, возврат управления ОС
    exit:
    mov ax, 4c00h
    int 21h
end start
&lt;/pre&gt;
&lt;p&gt;Для чтения символа используется функция &lt;tt class="docutils literal"&gt;16h BIOS&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;AH = 0&lt;/p&gt;
&lt;p&gt;На выходе в AL = ASCII-код символа, 0 или префикс скан-кода, АН = скан-код
нажатой клавиши или расширенный ASCII-код.&lt;/p&gt;
&lt;p&gt;Далее производится сравнение регистра AH со скан-кодом 60h (нажатие Ctrl+F3).&lt;/p&gt;
&lt;p&gt;Потом получаем состояния клавиатуры. Используется функция &lt;tt class="docutils literal"&gt;16h BIOS&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;AH = 12h&lt;/p&gt;
&lt;p&gt;На выходе в AX заносится состояние клавиатуры. Нас интересует только первый
бит AH (LeftCtrl) и первый бит AL (RightShift).&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;Состояние клавиатуры&lt;/h2&gt;
&lt;div class="section" id="al"&gt;
&lt;h3&gt;AL&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Бит 7: Ins&lt;/li&gt;
&lt;li&gt;Бит 6: CapsLock&lt;/li&gt;
&lt;li&gt;Бит 5: NumLock&lt;/li&gt;
&lt;li&gt;Бит 4: ScrollLock&lt;/li&gt;
&lt;li&gt;Бит 3: Alt (любой Alt для функции 02h, часто только левый Alt для 12h/22h)&lt;/li&gt;
&lt;li&gt;Бит 2: Ctrl (любой)&lt;/li&gt;
&lt;li&gt;Бит 1: LeftShift&lt;/li&gt;
&lt;li&gt;Бит 0: RightShift&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="ah"&gt;
&lt;h3&gt;AH&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Бит 7: SysRq&lt;/li&gt;
&lt;li&gt;Бит 6: CapsLock&lt;/li&gt;
&lt;li&gt;Бит 5: NumLock&lt;/li&gt;
&lt;li&gt;Бит 4: ScrollLock&lt;/li&gt;
&lt;li&gt;Бит 3: RightAlt&lt;/li&gt;
&lt;li&gt;Бит 2: RightCtrl&lt;/li&gt;
&lt;li&gt;Бит 1: LeftAlt&lt;/li&gt;
&lt;li&gt;Бит 0: LeftCtrl&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
</summary><category term="assembler"></category></entry><entry><title>Моделирование одноканальной СМО с отказами</title><link href="http://marselester.github.com/modeling-single-channel-queue-with-refusals.html" rel="alternate"></link><updated>2009-05-30T00:00:00+06:00</updated><author><name>Marsel Mavletkulov</name></author><id>tag:marselester.github.com,2009-05-30:modeling-single-channel-queue-with-refusals.html</id><summary type="html">&lt;p&gt;Дана одноканальная система массового обслуживания с отказами. В нее поступают
заявки через промежуток времени &lt;tt class="docutils literal"&gt;n&lt;/tt&gt;, где &lt;tt class="docutils literal"&gt;n&lt;/tt&gt; – случайная величина,
подчиненная равномерному закону распределения. Время обслуживания заявки
системой &lt;tt class="docutils literal"&gt;m&lt;/tt&gt; также является случайной величиной с показательным законом
распределения. Если к моменту прихода заявки канал занят, заявка покидает
систему необслуженной.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;lt;?php
// Интенсивность потока обслуживания
$m = 0.5;
// Время работы системы
$time_work = 70;
// Текущее время системы
$time_system = 0;
// Время, когда освободится канал
$chanel = 0;
// Количество заявок, которым отказано в обработке
$cnt_denied = 0;
// Количество обработанных заявок
$cnt_processed = 0;

/**
 * Равномерный закон распределения
 */
function uniform() {
    return rand(1, 1000) / 1000;
}

/**
 * Показательный закон распределения
 */
function exponential() {
    global $m;
    return (-1 / $m) * log(rand(1, 1000) / 1000);
}

while ($time_system &amp;lt;= $time_work) {
    // Время, через сколько поступила новая заявка
    $time_claim_in = uniform();

    $time_system += $time_claim_in;

    echo &amp;quot;Время, через сколько поступила новая заявка: $time_claim_in&amp;lt;br/&amp;gt;&amp;quot;;
    echo &amp;quot;Текущее время системы: $time_system&amp;lt;br/&amp;gt;&amp;quot;;

    // Проверка, свободен ли канал
    if ($chanel &amp;lt;= $time_system) {
        $cnt_processed++;

        // Время, на которое заявка заняла канал
        $time_claim_busy = exponential();
        $chanel = $time_system + $time_claim_busy;

        echo &amp;quot;Заявка заняла канал на: $time_claim_busy&amp;lt;br/&amp;gt;&amp;quot;;
        echo &amp;quot;Время, когда освободится канал: $chanel&amp;lt;br/&amp;gt;&amp;quot;;
    }
    // Отказываем заявке в обслуживании
    else {
        echo 'Заявке отказано&amp;lt;br/&amp;gt;';
        $cnt_denied++;
    }

    echo '&amp;lt;hr/&amp;gt;';
}

$cnt_total = $cnt_processed + $cnt_denied;
$P_deny = $cnt_denied / $cnt_total;
$Q = $cnt_processed / $cnt_total;
$A = $cnt_processed / $time_work;

echo &amp;quot;&amp;lt;b&amp;gt;Общее число заявок:&amp;lt;/b&amp;gt; $cnt_total&amp;lt;br/&amp;gt;&amp;quot;;
echo &amp;quot;&amp;lt;b&amp;gt;Количество обработанных заявок:&amp;lt;/b&amp;gt; $cnt_processed&amp;lt;br/&amp;gt;&amp;quot;;
echo &amp;quot;&amp;lt;b&amp;gt;Количество заявок, которым отказано в обработке:&amp;lt;/b&amp;gt; $cnt_denied&amp;lt;br/&amp;gt;&amp;quot;;
echo &amp;quot;&amp;lt;b&amp;gt;Вероятность отказа:&amp;lt;/b&amp;gt; $P_deny&amp;lt;br/&amp;gt;&amp;quot;;
echo &amp;quot;&amp;lt;b&amp;gt;Доля обслуженных заявок:&amp;lt;/b&amp;gt; $Q&amp;lt;br/&amp;gt;&amp;quot;;
echo &amp;quot;&amp;lt;b&amp;gt;Абсолютная пропускная способность:&amp;lt;/b&amp;gt; $A&amp;lt;br/&amp;gt;&amp;quot;;
?&amp;gt;
&lt;/pre&gt;
</summary><category term="php"></category><category term="modeling"></category><category term="single-channel queue"></category></entry></feed>